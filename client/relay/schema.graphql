type AdminUser implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  userId: Int!
  userName: String
  userPassword: String
}

# A condition to be used against `AdminUser` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input AdminUserCondition {
  # Checks for equality with the object’s `userId` field.
  userId: Int

  # Checks for equality with the object’s `userName` field.
  userName: String

  # Checks for equality with the object’s `userPassword` field.
  userPassword: String
}

input AdminUserInput {
  userId: Int!
  userName: String
  userPassword: String
}

# Represents an update to a `AdminUser`. Fields that are set will be updated.
input AdminUserPatch {
  userId: Int
  userName: String
  userPassword: String
}

type AdminUserPerm implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  userId: Int!
  pageName: String!
  permName: String!
}

# A condition to be used against `AdminUserPerm` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input AdminUserPermCondition {
  # Checks for equality with the object’s `userId` field.
  userId: Int

  # Checks for equality with the object’s `pageName` field.
  pageName: String

  # Checks for equality with the object’s `permName` field.
  permName: String
}

input AdminUserPermInput {
  userId: Int!
  pageName: String!
  permName: String!
}

# Represents an update to a `AdminUserPerm`. Fields that are set will be updated.
input AdminUserPermPatch {
  userId: Int
  pageName: String
  permName: String
}

# A connection to a list of `AdminUserPerm` values.
type AdminUserPermsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `AdminUserPerm` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `AdminUserPerm` and cursor to aid in pagination.
  edges: [AdminUserPermsEdge]

  # A list of `AdminUserPerm` objects.
  nodes: [AdminUserPerm!]
}

# A `AdminUserPerm` edge in the connection.
type AdminUserPermsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `AdminUserPerm` at the end of the edge.
  node: AdminUserPerm!
}

# Methods to use when ordering `AdminUserPerm`.
enum AdminUserPermsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  PAGE_NAME_ASC
  PAGE_NAME_DESC
  PERM_NAME_ASC
  PERM_NAME_DESC
}

# A connection to a list of `AdminUser` values.
type AdminUsersConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `AdminUser` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `AdminUser` and cursor to aid in pagination.
  edges: [AdminUsersEdge]

  # A list of `AdminUser` objects.
  nodes: [AdminUser!]
}

# A `AdminUser` edge in the connection.
type AdminUsersEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `AdminUser` at the end of the edge.
  node: AdminUser!
}

# Methods to use when ordering `AdminUser`.
enum AdminUsersOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  USER_NAME_ASC
  USER_NAME_DESC
  USER_PASSWORD_ASC
  USER_PASSWORD_DESC
}

# A connection to a list of `Category` values.
type CategoriesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Category` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Category` and cursor to aid in pagination.
  edges: [CategoriesEdge]

  # A list of `Category` objects.
  nodes: [Category!]
}

# A `Category` edge in the connection.
type CategoriesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Category` at the end of the edge.
  node: Category!
}

# Methods to use when ordering `Category`.
enum CategoriesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  SLUG_ASC
  SLUG_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

type Category implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String!
  slug: String!
  sortOrder: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads and enables pagination through a set of `PodcastCategory`.
  podcastCategoriesByCategoryId(
    # The method to use when ordering `PodcastCategory`.
    orderBy: PodcastCategoriesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PodcastCategoryCondition
  ): PodcastCategoriesConnection
}

# A condition to be used against `Category` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input CategoryCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `slug` field.
  slug: String

  # Checks for equality with the object’s `sortOrder` field.
  sortOrder: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input CategoryInput {
  id: Int
  name: String!
  slug: String!
  sortOrder: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `Category`. Fields that are set will be updated.
input CategoryPatch {
  id: Int
  name: String
  slug: String
  sortOrder: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

type Clip implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  omnyClipId: String!
  title: String!
  description: String
  imageUrl: String
  audioUrl: String
  videoUrl: String
  embedUrl: String
  durationSeconds: String
  publishState: ClipPublishState
  publishedUrl: String
  publishedDate: Datetime
  programId: String
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads and enables pagination through a set of `PlaylistClip`.
  playlistClipsByClipId(
    # The method to use when ordering `PlaylistClip`.
    orderBy: PlaylistClipsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PlaylistClipCondition
  ): PlaylistClipsConnection

  # Reads and enables pagination through a set of `PodcastClip`.
  podcastClipsByClipId(
    # The method to use when ordering `PodcastClip`.
    orderBy: PodcastClipsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PodcastClipCondition
  ): PodcastClipsConnection
}

# A condition to be used against `Clip` object types. All fields are tested for equality and combined with a logical ‘and.’
input ClipCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `omnyClipId` field.
  omnyClipId: String

  # Checks for equality with the object’s `title` field.
  title: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `imageUrl` field.
  imageUrl: String

  # Checks for equality with the object’s `audioUrl` field.
  audioUrl: String

  # Checks for equality with the object’s `videoUrl` field.
  videoUrl: String

  # Checks for equality with the object’s `embedUrl` field.
  embedUrl: String

  # Checks for equality with the object’s `durationSeconds` field.
  durationSeconds: String

  # Checks for equality with the object’s `publishState` field.
  publishState: ClipPublishState

  # Checks for equality with the object’s `publishedUrl` field.
  publishedUrl: String

  # Checks for equality with the object’s `publishedDate` field.
  publishedDate: Datetime

  # Checks for equality with the object’s `programId` field.
  programId: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input ClipInput {
  id: Int
  omnyClipId: String!
  title: String!
  description: String
  imageUrl: String
  audioUrl: String
  videoUrl: String
  embedUrl: String
  durationSeconds: String
  publishState: ClipPublishState
  publishedUrl: String
  publishedDate: Datetime
  programId: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `Clip`. Fields that are set will be updated.
input ClipPatch {
  id: Int
  omnyClipId: String
  title: String
  description: String
  imageUrl: String
  audioUrl: String
  videoUrl: String
  embedUrl: String
  durationSeconds: String
  publishState: ClipPublishState
  publishedUrl: String
  publishedDate: Datetime
  programId: String
  createdDate: Datetime
  modifiedDate: Datetime
}

enum ClipPublishState {
  PUBLISHED
  UNPUBLISHED
  PUBLISHING
}

# A connection to a list of `Clip` values.
type ClipsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Clip` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Clip` and cursor to aid in pagination.
  edges: [ClipsEdge]

  # A list of `Clip` objects.
  nodes: [Clip!]
}

# A `Clip` edge in the connection.
type ClipsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Clip` at the end of the edge.
  node: Clip!
}

# Methods to use when ordering `Clip`.
enum ClipsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  OMNY_CLIP_ID_ASC
  OMNY_CLIP_ID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  IMAGE_URL_ASC
  IMAGE_URL_DESC
  AUDIO_URL_ASC
  AUDIO_URL_DESC
  VIDEO_URL_ASC
  VIDEO_URL_DESC
  EMBED_URL_ASC
  EMBED_URL_DESC
  DURATION_SECONDS_ASC
  DURATION_SECONDS_DESC
  PUBLISH_STATE_ASC
  PUBLISH_STATE_DESC
  PUBLISHED_URL_ASC
  PUBLISHED_URL_DESC
  PUBLISHED_DATE_ASC
  PUBLISHED_DATE_DESC
  PROGRAM_ID_ASC
  PROGRAM_ID_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

# All input for the `createAdminUser` mutation.
input CreateAdminUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `AdminUser` to be created by this mutation.
  adminUser: AdminUserInput!
}

# The output of our `createAdminUser` mutation.
type CreateAdminUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `AdminUser` that was created by this mutation.
  adminUser: AdminUser

  # An edge for our `AdminUser`. May be used by Relay 1.
  adminUserEdge(
    # The method to use when ordering `AdminUser`.
    orderBy: AdminUsersOrderBy = PRIMARY_KEY_ASC
  ): AdminUsersEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createAdminUserPerm` mutation.
input CreateAdminUserPermInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `AdminUserPerm` to be created by this mutation.
  adminUserPerm: AdminUserPermInput!
}

# The output of our `createAdminUserPerm` mutation.
type CreateAdminUserPermPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `AdminUserPerm` that was created by this mutation.
  adminUserPerm: AdminUserPerm

  # An edge for our `AdminUserPerm`. May be used by Relay 1.
  adminUserPermEdge(
    # The method to use when ordering `AdminUserPerm`.
    orderBy: AdminUserPermsOrderBy = PRIMARY_KEY_ASC
  ): AdminUserPermsEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createCategory` mutation.
input CreateCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Category` to be created by this mutation.
  category: CategoryInput!
}

# The output of our `createCategory` mutation.
type CreateCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Category` that was created by this mutation.
  category: Category

  # An edge for our `Category`. May be used by Relay 1.
  categoryEdge(
    # The method to use when ordering `Category`.
    orderBy: CategoriesOrderBy = PRIMARY_KEY_ASC
  ): CategoriesEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createClip` mutation.
input CreateClipInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Clip` to be created by this mutation.
  clip: ClipInput!
}

# The output of our `createClip` mutation.
type CreateClipPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Clip` that was created by this mutation.
  clip: Clip

  # An edge for our `Clip`. May be used by Relay 1.
  clipEdge(
    # The method to use when ordering `Clip`.
    orderBy: ClipsOrderBy = PRIMARY_KEY_ASC
  ): ClipsEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createFeaturedPodcast` mutation.
input CreateFeaturedPodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `FeaturedPodcast` to be created by this mutation.
  featuredPodcast: FeaturedPodcastInput!
}

# The output of our `createFeaturedPodcast` mutation.
type CreateFeaturedPodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FeaturedPodcast` that was created by this mutation.
  featuredPodcast: FeaturedPodcast

  # An edge for our `FeaturedPodcast`. May be used by Relay 1.
  featuredPodcastEdge(
    # The method to use when ordering `FeaturedPodcast`.
    orderBy: FeaturedPodcastsOrderBy = PRIMARY_KEY_ASC
  ): FeaturedPodcastsEdge

  # Reads a single `Podcast` that is related to this `FeaturedPodcast`.
  podcastByPodcastId: Podcast

  # Reads a single `Market` that is related to this `FeaturedPodcast`.
  marketByMarketId: Market

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createFeaturedStation` mutation.
input CreateFeaturedStationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `FeaturedStation` to be created by this mutation.
  featuredStation: FeaturedStationInput!
}

# The output of our `createFeaturedStation` mutation.
type CreateFeaturedStationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `FeaturedStation` that was created by this mutation.
  featuredStation: FeaturedStation

  # An edge for our `FeaturedStation`. May be used by Relay 1.
  featuredStationEdge(
    # The method to use when ordering `FeaturedStation`.
    orderBy: FeaturedStationsOrderBy = PRIMARY_KEY_ASC
  ): FeaturedStationsEdge

  # Reads a single `Station` that is related to this `FeaturedStation`.
  stationByStationId: Station

  # Reads a single `Market` that is related to this `FeaturedStation`.
  marketByMarketId: Market

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createGenre` mutation.
input CreateGenreInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Genre` to be created by this mutation.
  genre: GenreInput!
}

# The output of our `createGenre` mutation.
type CreateGenrePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Genre` that was created by this mutation.
  genre: Genre

  # An edge for our `Genre`. May be used by Relay 1.
  genreEdge(
    # The method to use when ordering `Genre`.
    orderBy: GenresOrderBy = PRIMARY_KEY_ASC
  ): GenresEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createMarket` mutation.
input CreateMarketInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Market` to be created by this mutation.
  market: MarketInput!
}

# The output of our `createMarket` mutation.
type CreateMarketPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Market` that was created by this mutation.
  market: Market

  # An edge for our `Market`. May be used by Relay 1.
  marketEdge(
    # The method to use when ordering `Market`.
    orderBy: MarketsOrderBy = PRIMARY_KEY_ASC
  ): MarketsEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPlaylistClip` mutation.
input CreatePlaylistClipInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `PlaylistClip` to be created by this mutation.
  playlistClip: PlaylistClipInput!
}

# The output of our `createPlaylistClip` mutation.
type CreatePlaylistClipPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `PlaylistClip` that was created by this mutation.
  playlistClip: PlaylistClip

  # An edge for our `PlaylistClip`. May be used by Relay 1.
  playlistClipEdge(
    # The method to use when ordering `PlaylistClip`.
    orderBy: PlaylistClipsOrderBy = PRIMARY_KEY_ASC
  ): PlaylistClipsEdge

  # Reads a single `Playlist` that is related to this `PlaylistClip`.
  playlistByPlaylistId: Playlist

  # Reads a single `Clip` that is related to this `PlaylistClip`.
  clipByClipId: Clip

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPlaylist` mutation.
input CreatePlaylistInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Playlist` to be created by this mutation.
  playlist: PlaylistInput!
}

# The output of our `createPlaylist` mutation.
type CreatePlaylistPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Playlist` that was created by this mutation.
  playlist: Playlist

  # An edge for our `Playlist`. May be used by Relay 1.
  playlistEdge(
    # The method to use when ordering `Playlist`.
    orderBy: PlaylistsOrderBy = PRIMARY_KEY_ASC
  ): PlaylistsEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPodcastCategory` mutation.
input CreatePodcastCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `PodcastCategory` to be created by this mutation.
  podcastCategory: PodcastCategoryInput!
}

# The output of our `createPodcastCategory` mutation.
type CreatePodcastCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `PodcastCategory` that was created by this mutation.
  podcastCategory: PodcastCategory

  # An edge for our `PodcastCategory`. May be used by Relay 1.
  podcastCategoryEdge(
    # The method to use when ordering `PodcastCategory`.
    orderBy: PodcastCategoriesOrderBy = PRIMARY_KEY_ASC
  ): PodcastCategoriesEdge

  # Reads a single `Podcast` that is related to this `PodcastCategory`.
  podcastByPodcastId: Podcast

  # Reads a single `Category` that is related to this `PodcastCategory`.
  categoryByCategoryId: Category

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPodcastClip` mutation.
input CreatePodcastClipInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `PodcastClip` to be created by this mutation.
  podcastClip: PodcastClipInput!
}

# The output of our `createPodcastClip` mutation.
type CreatePodcastClipPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `PodcastClip` that was created by this mutation.
  podcastClip: PodcastClip

  # An edge for our `PodcastClip`. May be used by Relay 1.
  podcastClipEdge(
    # The method to use when ordering `PodcastClip`.
    orderBy: PodcastClipsOrderBy = PRIMARY_KEY_ASC
  ): PodcastClipsEdge

  # Reads a single `Podcast` that is related to this `PodcastClip`.
  podcastByPodcastId: Podcast

  # Reads a single `Clip` that is related to this `PodcastClip`.
  clipByClipId: Clip

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createPodcast` mutation.
input CreatePodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Podcast` to be created by this mutation.
  podcast: PodcastInput!
}

# The output of our `createPodcast` mutation.
type CreatePodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Podcast` that was created by this mutation.
  podcast: Podcast

  # An edge for our `Podcast`. May be used by Relay 1.
  podcastEdge(
    # The method to use when ordering `Podcast`.
    orderBy: PodcastsOrderBy = PRIMARY_KEY_ASC
  ): PodcastsEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createShow` mutation.
input CreateShowInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Show` to be created by this mutation.
  show: ShowInput!
}

# All input for the `createShowModuleCustom` mutation.
input CreateShowModuleCustomInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `ShowModuleCustom` to be created by this mutation.
  showModuleCustom: ShowModuleCustomInput!
}

# The output of our `createShowModuleCustom` mutation.
type CreateShowModuleCustomPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `ShowModuleCustom` that was created by this mutation.
  showModuleCustom: ShowModuleCustom

  # An edge for our `ShowModuleCustom`. May be used by Relay 1.
  showModuleCustomEdge(
    # The method to use when ordering `ShowModuleCustom`.
    orderBy: ShowModuleCustomsOrderBy = PRIMARY_KEY_ASC
  ): ShowModuleCustomsEdge

  # Reads a single `ShowModule` that is related to this `ShowModuleCustom`.
  showModuleByShowModuleId: ShowModule

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createShowModule` mutation.
input CreateShowModuleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `ShowModule` to be created by this mutation.
  showModule: ShowModuleInput!
}

# The output of our `createShowModule` mutation.
type CreateShowModulePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `ShowModule` that was created by this mutation.
  showModule: ShowModule

  # An edge for our `ShowModule`. May be used by Relay 1.
  showModuleEdge(
    # The method to use when ordering `ShowModule`.
    orderBy: ShowModulesOrderBy = PRIMARY_KEY_ASC
  ): ShowModulesEdge

  # Reads a single `Show` that is related to this `ShowModule`.
  showByShowId: Show

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `createShow` mutation.
type CreateShowPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Show` that was created by this mutation.
  show: Show

  # An edge for our `Show`. May be used by Relay 1.
  showEdge(
    # The method to use when ordering `Show`.
    orderBy: ShowsOrderBy = PRIMARY_KEY_ASC
  ): ShowsEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createShowPlaylist` mutation.
input CreateShowPlaylistInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `ShowPlaylist` to be created by this mutation.
  showPlaylist: ShowPlaylistInput!
}

# The output of our `createShowPlaylist` mutation.
type CreateShowPlaylistPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `ShowPlaylist` that was created by this mutation.
  showPlaylist: ShowPlaylist

  # An edge for our `ShowPlaylist`. May be used by Relay 1.
  showPlaylistEdge(
    # The method to use when ordering `ShowPlaylist`.
    orderBy: ShowPlaylistsOrderBy = PRIMARY_KEY_ASC
  ): ShowPlaylistsEdge

  # Reads a single `Show` that is related to this `ShowPlaylist`.
  showByShowId: Show

  # Reads a single `Playlist` that is related to this `ShowPlaylist`.
  playlistByPlaylistId: Playlist

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createShowPodcast` mutation.
input CreateShowPodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `ShowPodcast` to be created by this mutation.
  showPodcast: ShowPodcastInput!
}

# The output of our `createShowPodcast` mutation.
type CreateShowPodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `ShowPodcast` that was created by this mutation.
  showPodcast: ShowPodcast

  # An edge for our `ShowPodcast`. May be used by Relay 1.
  showPodcastEdge(
    # The method to use when ordering `ShowPodcast`.
    orderBy: ShowPodcastsOrderBy = PRIMARY_KEY_ASC
  ): ShowPodcastsEdge

  # Reads a single `Show` that is related to this `ShowPodcast`.
  showByShowId: Show

  # Reads a single `Podcast` that is related to this `ShowPodcast`.
  podcastByPodcastId: Podcast

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createSong` mutation.
input CreateSongInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Song` to be created by this mutation.
  song: SongInput!
}

# The output of our `createSong` mutation.
type CreateSongPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Song` that was created by this mutation.
  song: Song

  # An edge for our `Song`. May be used by Relay 1.
  songEdge(
    # The method to use when ordering `Song`.
    orderBy: SongsOrderBy = PRIMARY_KEY_ASC
  ): SongsEdge

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createSongPlay` mutation.
input CreateSongPlayInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `SongPlay` to be created by this mutation.
  songPlay: SongPlayInput!
}

# The output of our `createSongPlay` mutation.
type CreateSongPlayPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `SongPlay` that was created by this mutation.
  songPlay: SongPlay

  # An edge for our `SongPlay`. May be used by Relay 1.
  songPlayEdge(
    # The method to use when ordering `SongPlay`.
    orderBy: SongPlaysOrderBy = PRIMARY_KEY_ASC
  ): SongPlaysEdge

  # Reads a single `Song` that is related to this `SongPlay`.
  songBySongId: Song

  # Reads a single `Station` that is related to this `SongPlay`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createStationGenre` mutation.
input CreateStationGenreInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `StationGenre` to be created by this mutation.
  stationGenre: StationGenreInput!
}

# The output of our `createStationGenre` mutation.
type CreateStationGenrePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `StationGenre` that was created by this mutation.
  stationGenre: StationGenre

  # An edge for our `StationGenre`. May be used by Relay 1.
  stationGenreEdge(
    # The method to use when ordering `StationGenre`.
    orderBy: StationGenresOrderBy = PRIMARY_KEY_ASC
  ): StationGenresEdge

  # Reads a single `Station` that is related to this `StationGenre`.
  stationByStationId: Station

  # Reads a single `Genre` that is related to this `StationGenre`.
  genreByGenreId: Genre

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createStation` mutation.
input CreateStationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `Station` to be created by this mutation.
  station: StationInput!
}

# All input for the `createStationModuleCustom` mutation.
input CreateStationModuleCustomInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `StationModuleCustom` to be created by this mutation.
  stationModuleCustom: StationModuleCustomInput!
}

# The output of our `createStationModuleCustom` mutation.
type CreateStationModuleCustomPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `StationModuleCustom` that was created by this mutation.
  stationModuleCustom: StationModuleCustom

  # An edge for our `StationModuleCustom`. May be used by Relay 1.
  stationModuleCustomEdge(
    # The method to use when ordering `StationModuleCustom`.
    orderBy: StationModuleCustomsOrderBy = PRIMARY_KEY_ASC
  ): StationModuleCustomsEdge

  # Reads a single `StationModule` that is related to this `StationModuleCustom`.
  stationModuleByStationModuleId: StationModule

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createStationModule` mutation.
input CreateStationModuleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `StationModule` to be created by this mutation.
  stationModule: StationModuleInput!
}

# The output of our `createStationModule` mutation.
type CreateStationModulePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `StationModule` that was created by this mutation.
  stationModule: StationModule

  # An edge for our `StationModule`. May be used by Relay 1.
  stationModuleEdge(
    # The method to use when ordering `StationModule`.
    orderBy: StationModulesOrderBy = PRIMARY_KEY_ASC
  ): StationModulesEdge

  # Reads a single `Station` that is related to this `StationModule`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createStationMount` mutation.
input CreateStationMountInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `StationMount` to be created by this mutation.
  stationMount: StationMountInput!
}

# The output of our `createStationMount` mutation.
type CreateStationMountPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `StationMount` that was created by this mutation.
  stationMount: StationMount

  # An edge for our `StationMount`. May be used by Relay 1.
  stationMountEdge(
    # The method to use when ordering `StationMount`.
    orderBy: StationMountsOrderBy = PRIMARY_KEY_ASC
  ): StationMountsEdge

  # Reads a single `Station` that is related to this `StationMount`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `createStation` mutation.
type CreateStationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `Station` that was created by this mutation.
  station: Station

  # An edge for our `Station`. May be used by Relay 1.
  stationEdge(
    # The method to use when ordering `Station`.
    orderBy: StationsOrderBy = PRIMARY_KEY_ASC
  ): StationsEdge

  # Reads a single `Market` that is related to this `Station`.
  marketByMarketId: Market

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createStationPlaylist` mutation.
input CreateStationPlaylistInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `StationPlaylist` to be created by this mutation.
  stationPlaylist: StationPlaylistInput!
}

# The output of our `createStationPlaylist` mutation.
type CreateStationPlaylistPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `StationPlaylist` that was created by this mutation.
  stationPlaylist: StationPlaylist

  # An edge for our `StationPlaylist`. May be used by Relay 1.
  stationPlaylistEdge(
    # The method to use when ordering `StationPlaylist`.
    orderBy: StationPlaylistsOrderBy = PRIMARY_KEY_ASC
  ): StationPlaylistsEdge

  # Reads a single `Station` that is related to this `StationPlaylist`.
  stationByStationId: Station

  # Reads a single `Playlist` that is related to this `StationPlaylist`.
  playlistByPlaylistId: Playlist

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createStationPodcast` mutation.
input CreateStationPodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `StationPodcast` to be created by this mutation.
  stationPodcast: StationPodcastInput!
}

# The output of our `createStationPodcast` mutation.
type CreateStationPodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `StationPodcast` that was created by this mutation.
  stationPodcast: StationPodcast

  # An edge for our `StationPodcast`. May be used by Relay 1.
  stationPodcastEdge(
    # The method to use when ordering `StationPodcast`.
    orderBy: StationPodcastsOrderBy = PRIMARY_KEY_ASC
  ): StationPodcastsEdge

  # Reads a single `Station` that is related to this `StationPodcast`.
  stationByStationId: Station

  # Reads a single `Podcast` that is related to this `StationPodcast`.
  podcastByPodcastId: Podcast

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createStationShow` mutation.
input CreateStationShowInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `StationShow` to be created by this mutation.
  stationShow: StationShowInput!
}

# The output of our `createStationShow` mutation.
type CreateStationShowPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `StationShow` that was created by this mutation.
  stationShow: StationShow

  # An edge for our `StationShow`. May be used by Relay 1.
  stationShowEdge(
    # The method to use when ordering `StationShow`.
    orderBy: StationShowsOrderBy = PRIMARY_KEY_ASC
  ): StationShowsEdge

  # Reads a single `Station` that is related to this `StationShow`.
  stationByStationId: Station

  # Reads a single `Show` that is related to this `StationShow`.
  showByShowId: Show

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createStationShowSchedule` mutation.
input CreateStationShowScheduleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `StationShowSchedule` to be created by this mutation.
  stationShowSchedule: StationShowScheduleInput!
}

# The output of our `createStationShowSchedule` mutation.
type CreateStationShowSchedulePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `StationShowSchedule` that was created by this mutation.
  stationShowSchedule: StationShowSchedule

  # An edge for our `StationShowSchedule`. May be used by Relay 1.
  stationShowScheduleEdge(
    # The method to use when ordering `StationShowSchedule`.
    orderBy: StationShowSchedulesOrderBy = PRIMARY_KEY_ASC
  ): StationShowSchedulesEdge

  # Reads a single `StationShow` that is related to this `StationShowSchedule`.
  stationShowByStationShowId: StationShow

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `createStationStream` mutation.
input CreateStationStreamInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The `StationStream` to be created by this mutation.
  stationStream: StationStreamInput!
}

# The output of our `createStationStream` mutation.
type CreateStationStreamPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String

  # The `StationStream` that was created by this mutation.
  stationStream: StationStream

  # An edge for our `StationStream`. May be used by Relay 1.
  stationStreamEdge(
    # The method to use when ordering `StationStream`.
    orderBy: StationStreamsOrderBy = PRIMARY_KEY_ASC
  ): StationStreamsEdge

  # Reads a single `Station` that is related to this `StationStream`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

# All input for the `deleteAdminUserByUserId` mutation.
input DeleteAdminUserByUserIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  userId: Int!
}

# All input for the `deleteAdminUser` mutation.
input DeleteAdminUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `AdminUser` to be deleted.
  nodeId: ID!
}

# The output of our `deleteAdminUser` mutation.
type DeleteAdminUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  adminUser: AdminUser
  deletedAdminUserId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteAdminUserPermByUserIdAndPageNameAndPermName` mutation.
input DeleteAdminUserPermByUserIdAndPageNameAndPermNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  userId: Int!
  pageName: String!
  permName: String!
}

# All input for the `deleteAdminUserPerm` mutation.
input DeleteAdminUserPermInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `AdminUserPerm` to be deleted.
  nodeId: ID!
}

# The output of our `deleteAdminUserPerm` mutation.
type DeleteAdminUserPermPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  adminUserPerm: AdminUserPerm
  deletedAdminUserPermId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteCategoryById` mutation.
input DeleteCategoryByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteCategoryByName` mutation.
input DeleteCategoryByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deleteCategoryBySlug` mutation.
input DeleteCategoryBySlugInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  slug: String!
}

# All input for the `deleteCategory` mutation.
input DeleteCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Category` to be deleted.
  nodeId: ID!
}

# The output of our `deleteCategory` mutation.
type DeleteCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  category: Category
  deletedCategoryId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteClipById` mutation.
input DeleteClipByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteClipByOmnyClipId` mutation.
input DeleteClipByOmnyClipIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  omnyClipId: String!
}

# All input for the `deleteClip` mutation.
input DeleteClipInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Clip` to be deleted.
  nodeId: ID!
}

# The output of our `deleteClip` mutation.
type DeleteClipPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  clip: Clip
  deletedClipId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteFeaturedPodcastById` mutation.
input DeleteFeaturedPodcastByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteFeaturedPodcastByPodcastIdAndMarketId` mutation.
input DeleteFeaturedPodcastByPodcastIdAndMarketIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  podcastId: Int!
  marketId: Int!
}

# All input for the `deleteFeaturedPodcast` mutation.
input DeleteFeaturedPodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FeaturedPodcast` to be deleted.
  nodeId: ID!
}

# The output of our `deleteFeaturedPodcast` mutation.
type DeleteFeaturedPodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  featuredPodcast: FeaturedPodcast
  deletedFeaturedPodcastId: ID

  # Reads a single `Podcast` that is related to this `FeaturedPodcast`.
  podcastByPodcastId: Podcast

  # Reads a single `Market` that is related to this `FeaturedPodcast`.
  marketByMarketId: Market

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteFeaturedStationById` mutation.
input DeleteFeaturedStationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteFeaturedStationByStationIdAndMarketId` mutation.
input DeleteFeaturedStationByStationIdAndMarketIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  stationId: Int!
  marketId: Int!
}

# All input for the `deleteFeaturedStation` mutation.
input DeleteFeaturedStationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FeaturedStation` to be deleted.
  nodeId: ID!
}

# The output of our `deleteFeaturedStation` mutation.
type DeleteFeaturedStationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  featuredStation: FeaturedStation
  deletedFeaturedStationId: ID

  # Reads a single `Station` that is related to this `FeaturedStation`.
  stationByStationId: Station

  # Reads a single `Market` that is related to this `FeaturedStation`.
  marketByMarketId: Market

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteGenreById` mutation.
input DeleteGenreByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteGenreByName` mutation.
input DeleteGenreByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deleteGenreBySlug` mutation.
input DeleteGenreBySlugInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  slug: String!
}

# All input for the `deleteGenre` mutation.
input DeleteGenreInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Genre` to be deleted.
  nodeId: ID!
}

# The output of our `deleteGenre` mutation.
type DeleteGenrePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  genre: Genre
  deletedGenreId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteMarketById` mutation.
input DeleteMarketByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteMarketByName` mutation.
input DeleteMarketByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!
}

# All input for the `deleteMarket` mutation.
input DeleteMarketInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Market` to be deleted.
  nodeId: ID!
}

# The output of our `deleteMarket` mutation.
type DeleteMarketPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  market: Market
  deletedMarketId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deletePlaylistById` mutation.
input DeletePlaylistByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deletePlaylistByOmnyPlaylistId` mutation.
input DeletePlaylistByOmnyPlaylistIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  omnyPlaylistId: String!
}

# All input for the `deletePlaylistClipById` mutation.
input DeletePlaylistClipByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deletePlaylistClipByPlaylistIdAndClipId` mutation.
input DeletePlaylistClipByPlaylistIdAndClipIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  playlistId: Int!
  clipId: Int!
}

# All input for the `deletePlaylistClip` mutation.
input DeletePlaylistClipInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PlaylistClip` to be deleted.
  nodeId: ID!
}

# The output of our `deletePlaylistClip` mutation.
type DeletePlaylistClipPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  playlistClip: PlaylistClip
  deletedPlaylistClipId: ID

  # Reads a single `Playlist` that is related to this `PlaylistClip`.
  playlistByPlaylistId: Playlist

  # Reads a single `Clip` that is related to this `PlaylistClip`.
  clipByClipId: Clip

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deletePlaylist` mutation.
input DeletePlaylistInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Playlist` to be deleted.
  nodeId: ID!
}

# The output of our `deletePlaylist` mutation.
type DeletePlaylistPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  playlist: Playlist
  deletedPlaylistId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deletePodcastById` mutation.
input DeletePodcastByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deletePodcastByOmnyPlaylistId` mutation.
input DeletePodcastByOmnyPlaylistIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  omnyPlaylistId: String!
}

# All input for the `deletePodcastCategoryById` mutation.
input DeletePodcastCategoryByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deletePodcastCategoryByPodcastIdAndCategoryId` mutation.
input DeletePodcastCategoryByPodcastIdAndCategoryIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  podcastId: Int!
  categoryId: Int!
}

# All input for the `deletePodcastCategory` mutation.
input DeletePodcastCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PodcastCategory` to be deleted.
  nodeId: ID!
}

# The output of our `deletePodcastCategory` mutation.
type DeletePodcastCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  podcastCategory: PodcastCategory
  deletedPodcastCategoryId: ID

  # Reads a single `Podcast` that is related to this `PodcastCategory`.
  podcastByPodcastId: Podcast

  # Reads a single `Category` that is related to this `PodcastCategory`.
  categoryByCategoryId: Category

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deletePodcastClipById` mutation.
input DeletePodcastClipByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deletePodcastClipByPodcastIdAndClipId` mutation.
input DeletePodcastClipByPodcastIdAndClipIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  podcastId: Int!
  clipId: Int!
}

# All input for the `deletePodcastClip` mutation.
input DeletePodcastClipInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PodcastClip` to be deleted.
  nodeId: ID!
}

# The output of our `deletePodcastClip` mutation.
type DeletePodcastClipPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  podcastClip: PodcastClip
  deletedPodcastClipId: ID

  # Reads a single `Podcast` that is related to this `PodcastClip`.
  podcastByPodcastId: Podcast

  # Reads a single `Clip` that is related to this `PodcastClip`.
  clipByClipId: Clip

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deletePodcast` mutation.
input DeletePodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Podcast` to be deleted.
  nodeId: ID!
}

# The output of our `deletePodcast` mutation.
type DeletePodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  podcast: Podcast
  deletedPodcastId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteShowById` mutation.
input DeleteShowByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteShowByProgramId` mutation.
input DeleteShowByProgramIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  programId: String!
}

# All input for the `deleteShow` mutation.
input DeleteShowInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Show` to be deleted.
  nodeId: ID!
}

# All input for the `deleteShowModuleById` mutation.
input DeleteShowModuleByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteShowModuleCustomById` mutation.
input DeleteShowModuleCustomByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteShowModuleCustom` mutation.
input DeleteShowModuleCustomInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ShowModuleCustom` to be deleted.
  nodeId: ID!
}

# The output of our `deleteShowModuleCustom` mutation.
type DeleteShowModuleCustomPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  showModuleCustom: ShowModuleCustom
  deletedShowModuleCustomId: ID

  # Reads a single `ShowModule` that is related to this `ShowModuleCustom`.
  showModuleByShowModuleId: ShowModule

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteShowModule` mutation.
input DeleteShowModuleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ShowModule` to be deleted.
  nodeId: ID!
}

# The output of our `deleteShowModule` mutation.
type DeleteShowModulePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  showModule: ShowModule
  deletedShowModuleId: ID

  # Reads a single `Show` that is related to this `ShowModule`.
  showByShowId: Show

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `deleteShow` mutation.
type DeleteShowPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  show: Show
  deletedShowId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteShowPlaylistById` mutation.
input DeleteShowPlaylistByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteShowPlaylistByShowIdAndPlaylistId` mutation.
input DeleteShowPlaylistByShowIdAndPlaylistIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  showId: Int!
  playlistId: Int!
}

# All input for the `deleteShowPlaylist` mutation.
input DeleteShowPlaylistInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ShowPlaylist` to be deleted.
  nodeId: ID!
}

# The output of our `deleteShowPlaylist` mutation.
type DeleteShowPlaylistPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  showPlaylist: ShowPlaylist
  deletedShowPlaylistId: ID

  # Reads a single `Show` that is related to this `ShowPlaylist`.
  showByShowId: Show

  # Reads a single `Playlist` that is related to this `ShowPlaylist`.
  playlistByPlaylistId: Playlist

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteShowPodcastById` mutation.
input DeleteShowPodcastByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteShowPodcastByShowIdAndPodcastId` mutation.
input DeleteShowPodcastByShowIdAndPodcastIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  showId: Int!
  podcastId: Int!
}

# All input for the `deleteShowPodcast` mutation.
input DeleteShowPodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ShowPodcast` to be deleted.
  nodeId: ID!
}

# The output of our `deleteShowPodcast` mutation.
type DeleteShowPodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  showPodcast: ShowPodcast
  deletedShowPodcastId: ID

  # Reads a single `Show` that is related to this `ShowPodcast`.
  showByShowId: Show

  # Reads a single `Podcast` that is related to this `ShowPodcast`.
  podcastByPodcastId: Podcast

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteSongById` mutation.
input DeleteSongByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteSongByUfid` mutation.
input DeleteSongByUfidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  ufid: String!
}

# All input for the `deleteSong` mutation.
input DeleteSongInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Song` to be deleted.
  nodeId: ID!
}

# The output of our `deleteSong` mutation.
type DeleteSongPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  song: Song
  deletedSongId: ID

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteSongPlayById` mutation.
input DeleteSongPlayByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteSongPlay` mutation.
input DeleteSongPlayInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `SongPlay` to be deleted.
  nodeId: ID!
}

# The output of our `deleteSongPlay` mutation.
type DeleteSongPlayPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  songPlay: SongPlay
  deletedSongPlayId: ID

  # Reads a single `Song` that is related to this `SongPlay`.
  songBySongId: Song

  # Reads a single `Station` that is related to this `SongPlay`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteStationById` mutation.
input DeleteStationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteStationByR20id` mutation.
input DeleteStationByR20idInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  r20id: Int!
}

# All input for the `deleteStationGenreById` mutation.
input DeleteStationGenreByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteStationGenreByStationIdAndGenreId` mutation.
input DeleteStationGenreByStationIdAndGenreIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  stationId: Int!
  genreId: Int!
}

# All input for the `deleteStationGenre` mutation.
input DeleteStationGenreInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationGenre` to be deleted.
  nodeId: ID!
}

# The output of our `deleteStationGenre` mutation.
type DeleteStationGenrePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationGenre: StationGenre
  deletedStationGenreId: ID

  # Reads a single `Station` that is related to this `StationGenre`.
  stationByStationId: Station

  # Reads a single `Genre` that is related to this `StationGenre`.
  genreByGenreId: Genre

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteStation` mutation.
input DeleteStationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Station` to be deleted.
  nodeId: ID!
}

# All input for the `deleteStationModuleById` mutation.
input DeleteStationModuleByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteStationModuleCustomById` mutation.
input DeleteStationModuleCustomByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteStationModuleCustom` mutation.
input DeleteStationModuleCustomInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationModuleCustom` to be deleted.
  nodeId: ID!
}

# The output of our `deleteStationModuleCustom` mutation.
type DeleteStationModuleCustomPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationModuleCustom: StationModuleCustom
  deletedStationModuleCustomId: ID

  # Reads a single `StationModule` that is related to this `StationModuleCustom`.
  stationModuleByStationModuleId: StationModule

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteStationModule` mutation.
input DeleteStationModuleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationModule` to be deleted.
  nodeId: ID!
}

# The output of our `deleteStationModule` mutation.
type DeleteStationModulePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationModule: StationModule
  deletedStationModuleId: ID

  # Reads a single `Station` that is related to this `StationModule`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteStationMountById` mutation.
input DeleteStationMountByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteStationMount` mutation.
input DeleteStationMountInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationMount` to be deleted.
  nodeId: ID!
}

# The output of our `deleteStationMount` mutation.
type DeleteStationMountPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationMount: StationMount
  deletedStationMountId: ID

  # Reads a single `Station` that is related to this `StationMount`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `deleteStation` mutation.
type DeleteStationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  station: Station
  deletedStationId: ID

  # Reads a single `Market` that is related to this `Station`.
  marketByMarketId: Market

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteStationPlaylistById` mutation.
input DeleteStationPlaylistByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteStationPlaylistByStationIdAndPlaylistId` mutation.
input DeleteStationPlaylistByStationIdAndPlaylistIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  stationId: Int!
  playlistId: Int!
}

# All input for the `deleteStationPlaylist` mutation.
input DeleteStationPlaylistInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationPlaylist` to be deleted.
  nodeId: ID!
}

# The output of our `deleteStationPlaylist` mutation.
type DeleteStationPlaylistPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationPlaylist: StationPlaylist
  deletedStationPlaylistId: ID

  # Reads a single `Station` that is related to this `StationPlaylist`.
  stationByStationId: Station

  # Reads a single `Playlist` that is related to this `StationPlaylist`.
  playlistByPlaylistId: Playlist

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteStationPodcastById` mutation.
input DeleteStationPodcastByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteStationPodcastByStationIdAndPodcastId` mutation.
input DeleteStationPodcastByStationIdAndPodcastIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  stationId: Int!
  podcastId: Int!
}

# All input for the `deleteStationPodcast` mutation.
input DeleteStationPodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationPodcast` to be deleted.
  nodeId: ID!
}

# The output of our `deleteStationPodcast` mutation.
type DeleteStationPodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationPodcast: StationPodcast
  deletedStationPodcastId: ID

  # Reads a single `Station` that is related to this `StationPodcast`.
  stationByStationId: Station

  # Reads a single `Podcast` that is related to this `StationPodcast`.
  podcastByPodcastId: Podcast

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteStationShowById` mutation.
input DeleteStationShowByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteStationShow` mutation.
input DeleteStationShowInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationShow` to be deleted.
  nodeId: ID!
}

# The output of our `deleteStationShow` mutation.
type DeleteStationShowPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationShow: StationShow
  deletedStationShowId: ID

  # Reads a single `Station` that is related to this `StationShow`.
  stationByStationId: Station

  # Reads a single `Show` that is related to this `StationShow`.
  showByShowId: Show

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteStationShowScheduleById` mutation.
input DeleteStationShowScheduleByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteStationShowSchedule` mutation.
input DeleteStationShowScheduleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationShowSchedule` to be deleted.
  nodeId: ID!
}

# The output of our `deleteStationShowSchedule` mutation.
type DeleteStationShowSchedulePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationShowSchedule: StationShowSchedule
  deletedStationShowScheduleId: ID

  # Reads a single `StationShow` that is related to this `StationShowSchedule`.
  stationShowByStationShowId: StationShow

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `deleteStationStreamById` mutation.
input DeleteStationStreamByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!
}

# All input for the `deleteStationStream` mutation.
input DeleteStationStreamInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationStream` to be deleted.
  nodeId: ID!
}

# The output of our `deleteStationStream` mutation.
type DeleteStationStreamPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationStream: StationStream
  deletedStationStreamId: ID

  # Reads a single `Station` that is related to this `StationStream`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

type FeaturedPodcast implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  podcastId: Int!
  marketId: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Podcast` that is related to this `FeaturedPodcast`.
  podcastByPodcastId: Podcast

  # Reads a single `Market` that is related to this `FeaturedPodcast`.
  marketByMarketId: Market
}

# A condition to be used against `FeaturedPodcast` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input FeaturedPodcastCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `podcastId` field.
  podcastId: Int

  # Checks for equality with the object’s `marketId` field.
  marketId: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input FeaturedPodcastInput {
  id: Int
  podcastId: Int!
  marketId: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `FeaturedPodcast`. Fields that are set will be updated.
input FeaturedPodcastPatch {
  id: Int
  podcastId: Int
  marketId: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `FeaturedPodcast` values.
type FeaturedPodcastsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `FeaturedPodcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `FeaturedPodcast` and cursor to aid in pagination.
  edges: [FeaturedPodcastsEdge]

  # A list of `FeaturedPodcast` objects.
  nodes: [FeaturedPodcast!]
}

# A `FeaturedPodcast` edge in the connection.
type FeaturedPodcastsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `FeaturedPodcast` at the end of the edge.
  node: FeaturedPodcast!
}

# Methods to use when ordering `FeaturedPodcast`.
enum FeaturedPodcastsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  PODCAST_ID_ASC
  PODCAST_ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

type FeaturedStation implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  stationId: Int!
  marketId: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Station` that is related to this `FeaturedStation`.
  stationByStationId: Station

  # Reads a single `Market` that is related to this `FeaturedStation`.
  marketByMarketId: Market
}

# A condition to be used against `FeaturedStation` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input FeaturedStationCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `stationId` field.
  stationId: Int

  # Checks for equality with the object’s `marketId` field.
  marketId: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input FeaturedStationInput {
  id: Int
  stationId: Int!
  marketId: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `FeaturedStation`. Fields that are set will be updated.
input FeaturedStationPatch {
  id: Int
  stationId: Int
  marketId: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `FeaturedStation` values.
type FeaturedStationsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `FeaturedStation` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `FeaturedStation` and cursor to aid in pagination.
  edges: [FeaturedStationsEdge]

  # A list of `FeaturedStation` objects.
  nodes: [FeaturedStation!]
}

# A `FeaturedStation` edge in the connection.
type FeaturedStationsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `FeaturedStation` at the end of the edge.
  node: FeaturedStation!
}

# Methods to use when ordering `FeaturedStation`.
enum FeaturedStationsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STATION_ID_ASC
  STATION_ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

# All input for the `genRandomBytes` mutation.
input GenRandomBytesInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  arg0: Int!
}

# The output of our `genRandomBytes` mutation.
type GenRandomBytesPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  string: String

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `genRandomUuid` mutation.
input GenRandomUuidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
}

# The output of our `genRandomUuid` mutation.
type GenRandomUuidPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  uuid: Uuid

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

type Genre implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String!
  slug: String!
  sortOrder: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads and enables pagination through a set of `StationGenre`.
  stationGenresByGenreId(
    # The method to use when ordering `StationGenre`.
    orderBy: StationGenresOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationGenreCondition
  ): StationGenresConnection
}

# A condition to be used against `Genre` object types. All fields are tested for equality and combined with a logical ‘and.’
input GenreCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `slug` field.
  slug: String

  # Checks for equality with the object’s `sortOrder` field.
  sortOrder: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input GenreInput {
  id: Int
  name: String!
  slug: String!
  sortOrder: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `Genre`. Fields that are set will be updated.
input GenrePatch {
  id: Int
  name: String
  slug: String
  sortOrder: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `Genre` values.
type GenresConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Genre` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Genre` and cursor to aid in pagination.
  edges: [GenresEdge]

  # A list of `Genre` objects.
  nodes: [Genre!]
}

# A `Genre` edge in the connection.
type GenresEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Genre` at the end of the edge.
  node: Genre!
}

# Methods to use when ordering `Genre`.
enum GenresOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  SLUG_ASC
  SLUG_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

type Market implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String!
  displayName: String
  state: String
  stateFull: String
  timezone: String
  latitude: Float
  longitude: Float
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads and enables pagination through a set of `Station`.
  stationsByMarketId(
    # The method to use when ordering `Station`.
    orderBy: StationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationCondition
  ): StationsConnection

  # Reads and enables pagination through a set of `FeaturedPodcast`.
  featuredPodcastsByMarketId(
    # The method to use when ordering `FeaturedPodcast`.
    orderBy: FeaturedPodcastsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FeaturedPodcastCondition
  ): FeaturedPodcastsConnection

  # Reads and enables pagination through a set of `FeaturedStation`.
  featuredStationsByMarketId(
    # The method to use when ordering `FeaturedStation`.
    orderBy: FeaturedStationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FeaturedStationCondition
  ): FeaturedStationsConnection
}

# A condition to be used against `Market` object types. All fields are tested for equality and combined with a logical ‘and.’
input MarketCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `displayName` field.
  displayName: String

  # Checks for equality with the object’s `state` field.
  state: String

  # Checks for equality with the object’s `stateFull` field.
  stateFull: String

  # Checks for equality with the object’s `timezone` field.
  timezone: String

  # Checks for equality with the object’s `latitude` field.
  latitude: Float

  # Checks for equality with the object’s `longitude` field.
  longitude: Float

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input MarketInput {
  id: Int
  name: String!
  displayName: String
  state: String
  stateFull: String
  timezone: String
  latitude: Float
  longitude: Float
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `Market`. Fields that are set will be updated.
input MarketPatch {
  id: Int
  name: String
  displayName: String
  state: String
  stateFull: String
  timezone: String
  latitude: Float
  longitude: Float
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `Market` values.
type MarketsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Market` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Market` and cursor to aid in pagination.
  edges: [MarketsEdge]

  # A list of `Market` objects.
  nodes: [Market!]
}

# A `Market` edge in the connection.
type MarketsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Market` at the end of the edge.
  node: Market!
}

# Methods to use when ordering `Market`.
enum MarketsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DISPLAY_NAME_ASC
  DISPLAY_NAME_DESC
  STATE_ASC
  STATE_DESC
  STATE_FULL_ASC
  STATE_FULL_DESC
  TIMEZONE_ASC
  TIMEZONE_DESC
  LATITUDE_ASC
  LATITUDE_DESC
  LONGITUDE_ASC
  LONGITUDE_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

enum ModuleType {
  PLAYLIST
  PODCASTS
  SCHEDULE
  RECENTLY_PLAYED
  CUSTOM
  CUSTOM_THUMB
  CUSTOM_SUB
  CUSTOM_THUMB_SUB
}

enum MountType {
  MP3
  MP3_DIALUP
  AAC
  AAC_DIALUP
  HLS_ADP
}

# The root mutation type which contains root level fields which mutate data.
type Mutation {
  genRandomBytes(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: GenRandomBytesInput!
  ): GenRandomBytesPayload
  genRandomUuid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: GenRandomUuidInput!
  ): GenRandomUuidPayload
  updateDate(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateDateInput!
  ): UpdateDatePayload

  # Creates a single `AdminUserPerm`.
  createAdminUserPerm(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateAdminUserPermInput!
  ): CreateAdminUserPermPayload

  # Updates a single `AdminUserPerm` using its globally unique id and a patch.
  updateAdminUserPerm(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateAdminUserPermInput!
  ): UpdateAdminUserPermPayload

  # Updates a single `AdminUserPerm` using a unique key and a patch.
  updateAdminUserPermByUserIdAndPageNameAndPermName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateAdminUserPermByUserIdAndPageNameAndPermNameInput!
  ): UpdateAdminUserPermPayload

  # Deletes a single `AdminUserPerm` using its globally unique id.
  deleteAdminUserPerm(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteAdminUserPermInput!
  ): DeleteAdminUserPermPayload

  # Deletes a single `AdminUserPerm` using a unique key.
  deleteAdminUserPermByUserIdAndPageNameAndPermName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteAdminUserPermByUserIdAndPageNameAndPermNameInput!
  ): DeleteAdminUserPermPayload

  # Creates a single `AdminUser`.
  createAdminUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateAdminUserInput!
  ): CreateAdminUserPayload

  # Updates a single `AdminUser` using its globally unique id and a patch.
  updateAdminUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateAdminUserInput!
  ): UpdateAdminUserPayload

  # Updates a single `AdminUser` using a unique key and a patch.
  updateAdminUserByUserId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateAdminUserByUserIdInput!
  ): UpdateAdminUserPayload

  # Deletes a single `AdminUser` using its globally unique id.
  deleteAdminUser(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteAdminUserInput!
  ): DeleteAdminUserPayload

  # Deletes a single `AdminUser` using a unique key.
  deleteAdminUserByUserId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteAdminUserByUserIdInput!
  ): DeleteAdminUserPayload

  # Creates a single `Category`.
  createCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateCategoryInput!
  ): CreateCategoryPayload

  # Updates a single `Category` using its globally unique id and a patch.
  updateCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCategoryInput!
  ): UpdateCategoryPayload

  # Updates a single `Category` using a unique key and a patch.
  updateCategoryById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCategoryByIdInput!
  ): UpdateCategoryPayload

  # Updates a single `Category` using a unique key and a patch.
  updateCategoryByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCategoryByNameInput!
  ): UpdateCategoryPayload

  # Updates a single `Category` using a unique key and a patch.
  updateCategoryBySlug(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateCategoryBySlugInput!
  ): UpdateCategoryPayload

  # Deletes a single `Category` using its globally unique id.
  deleteCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCategoryInput!
  ): DeleteCategoryPayload

  # Deletes a single `Category` using a unique key.
  deleteCategoryById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCategoryByIdInput!
  ): DeleteCategoryPayload

  # Deletes a single `Category` using a unique key.
  deleteCategoryByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCategoryByNameInput!
  ): DeleteCategoryPayload

  # Deletes a single `Category` using a unique key.
  deleteCategoryBySlug(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteCategoryBySlugInput!
  ): DeleteCategoryPayload

  # Creates a single `Clip`.
  createClip(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateClipInput!
  ): CreateClipPayload

  # Updates a single `Clip` using its globally unique id and a patch.
  updateClip(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateClipInput!
  ): UpdateClipPayload

  # Updates a single `Clip` using a unique key and a patch.
  updateClipById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateClipByIdInput!
  ): UpdateClipPayload

  # Updates a single `Clip` using a unique key and a patch.
  updateClipByOmnyClipId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateClipByOmnyClipIdInput!
  ): UpdateClipPayload

  # Deletes a single `Clip` using its globally unique id.
  deleteClip(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteClipInput!
  ): DeleteClipPayload

  # Deletes a single `Clip` using a unique key.
  deleteClipById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteClipByIdInput!
  ): DeleteClipPayload

  # Deletes a single `Clip` using a unique key.
  deleteClipByOmnyClipId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteClipByOmnyClipIdInput!
  ): DeleteClipPayload

  # Creates a single `FeaturedPodcast`.
  createFeaturedPodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateFeaturedPodcastInput!
  ): CreateFeaturedPodcastPayload

  # Updates a single `FeaturedPodcast` using its globally unique id and a patch.
  updateFeaturedPodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFeaturedPodcastInput!
  ): UpdateFeaturedPodcastPayload

  # Updates a single `FeaturedPodcast` using a unique key and a patch.
  updateFeaturedPodcastById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFeaturedPodcastByIdInput!
  ): UpdateFeaturedPodcastPayload

  # Updates a single `FeaturedPodcast` using a unique key and a patch.
  updateFeaturedPodcastByPodcastIdAndMarketId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFeaturedPodcastByPodcastIdAndMarketIdInput!
  ): UpdateFeaturedPodcastPayload

  # Deletes a single `FeaturedPodcast` using its globally unique id.
  deleteFeaturedPodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFeaturedPodcastInput!
  ): DeleteFeaturedPodcastPayload

  # Deletes a single `FeaturedPodcast` using a unique key.
  deleteFeaturedPodcastById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFeaturedPodcastByIdInput!
  ): DeleteFeaturedPodcastPayload

  # Deletes a single `FeaturedPodcast` using a unique key.
  deleteFeaturedPodcastByPodcastIdAndMarketId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFeaturedPodcastByPodcastIdAndMarketIdInput!
  ): DeleteFeaturedPodcastPayload

  # Creates a single `FeaturedStation`.
  createFeaturedStation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateFeaturedStationInput!
  ): CreateFeaturedStationPayload

  # Updates a single `FeaturedStation` using its globally unique id and a patch.
  updateFeaturedStation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFeaturedStationInput!
  ): UpdateFeaturedStationPayload

  # Updates a single `FeaturedStation` using a unique key and a patch.
  updateFeaturedStationById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFeaturedStationByIdInput!
  ): UpdateFeaturedStationPayload

  # Updates a single `FeaturedStation` using a unique key and a patch.
  updateFeaturedStationByStationIdAndMarketId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateFeaturedStationByStationIdAndMarketIdInput!
  ): UpdateFeaturedStationPayload

  # Deletes a single `FeaturedStation` using its globally unique id.
  deleteFeaturedStation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFeaturedStationInput!
  ): DeleteFeaturedStationPayload

  # Deletes a single `FeaturedStation` using a unique key.
  deleteFeaturedStationById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFeaturedStationByIdInput!
  ): DeleteFeaturedStationPayload

  # Deletes a single `FeaturedStation` using a unique key.
  deleteFeaturedStationByStationIdAndMarketId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteFeaturedStationByStationIdAndMarketIdInput!
  ): DeleteFeaturedStationPayload

  # Creates a single `Genre`.
  createGenre(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateGenreInput!
  ): CreateGenrePayload

  # Updates a single `Genre` using its globally unique id and a patch.
  updateGenre(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateGenreInput!
  ): UpdateGenrePayload

  # Updates a single `Genre` using a unique key and a patch.
  updateGenreById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateGenreByIdInput!
  ): UpdateGenrePayload

  # Updates a single `Genre` using a unique key and a patch.
  updateGenreByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateGenreByNameInput!
  ): UpdateGenrePayload

  # Updates a single `Genre` using a unique key and a patch.
  updateGenreBySlug(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateGenreBySlugInput!
  ): UpdateGenrePayload

  # Deletes a single `Genre` using its globally unique id.
  deleteGenre(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteGenreInput!
  ): DeleteGenrePayload

  # Deletes a single `Genre` using a unique key.
  deleteGenreById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteGenreByIdInput!
  ): DeleteGenrePayload

  # Deletes a single `Genre` using a unique key.
  deleteGenreByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteGenreByNameInput!
  ): DeleteGenrePayload

  # Deletes a single `Genre` using a unique key.
  deleteGenreBySlug(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteGenreBySlugInput!
  ): DeleteGenrePayload

  # Creates a single `Market`.
  createMarket(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateMarketInput!
  ): CreateMarketPayload

  # Updates a single `Market` using its globally unique id and a patch.
  updateMarket(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMarketInput!
  ): UpdateMarketPayload

  # Updates a single `Market` using a unique key and a patch.
  updateMarketById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMarketByIdInput!
  ): UpdateMarketPayload

  # Updates a single `Market` using a unique key and a patch.
  updateMarketByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateMarketByNameInput!
  ): UpdateMarketPayload

  # Deletes a single `Market` using its globally unique id.
  deleteMarket(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMarketInput!
  ): DeleteMarketPayload

  # Deletes a single `Market` using a unique key.
  deleteMarketById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMarketByIdInput!
  ): DeleteMarketPayload

  # Deletes a single `Market` using a unique key.
  deleteMarketByName(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteMarketByNameInput!
  ): DeleteMarketPayload

  # Creates a single `Playlist`.
  createPlaylist(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePlaylistInput!
  ): CreatePlaylistPayload

  # Updates a single `Playlist` using its globally unique id and a patch.
  updatePlaylist(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaylistInput!
  ): UpdatePlaylistPayload

  # Updates a single `Playlist` using a unique key and a patch.
  updatePlaylistById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaylistByIdInput!
  ): UpdatePlaylistPayload

  # Updates a single `Playlist` using a unique key and a patch.
  updatePlaylistByOmnyPlaylistId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaylistByOmnyPlaylistIdInput!
  ): UpdatePlaylistPayload

  # Deletes a single `Playlist` using its globally unique id.
  deletePlaylist(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaylistInput!
  ): DeletePlaylistPayload

  # Deletes a single `Playlist` using a unique key.
  deletePlaylistById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaylistByIdInput!
  ): DeletePlaylistPayload

  # Deletes a single `Playlist` using a unique key.
  deletePlaylistByOmnyPlaylistId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaylistByOmnyPlaylistIdInput!
  ): DeletePlaylistPayload

  # Creates a single `PlaylistClip`.
  createPlaylistClip(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePlaylistClipInput!
  ): CreatePlaylistClipPayload

  # Updates a single `PlaylistClip` using its globally unique id and a patch.
  updatePlaylistClip(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaylistClipInput!
  ): UpdatePlaylistClipPayload

  # Updates a single `PlaylistClip` using a unique key and a patch.
  updatePlaylistClipById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaylistClipByIdInput!
  ): UpdatePlaylistClipPayload

  # Updates a single `PlaylistClip` using a unique key and a patch.
  updatePlaylistClipByPlaylistIdAndClipId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePlaylistClipByPlaylistIdAndClipIdInput!
  ): UpdatePlaylistClipPayload

  # Deletes a single `PlaylistClip` using its globally unique id.
  deletePlaylistClip(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaylistClipInput!
  ): DeletePlaylistClipPayload

  # Deletes a single `PlaylistClip` using a unique key.
  deletePlaylistClipById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaylistClipByIdInput!
  ): DeletePlaylistClipPayload

  # Deletes a single `PlaylistClip` using a unique key.
  deletePlaylistClipByPlaylistIdAndClipId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePlaylistClipByPlaylistIdAndClipIdInput!
  ): DeletePlaylistClipPayload

  # Creates a single `Podcast`.
  createPodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePodcastInput!
  ): CreatePodcastPayload

  # Updates a single `Podcast` using its globally unique id and a patch.
  updatePodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePodcastInput!
  ): UpdatePodcastPayload

  # Updates a single `Podcast` using a unique key and a patch.
  updatePodcastById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePodcastByIdInput!
  ): UpdatePodcastPayload

  # Updates a single `Podcast` using a unique key and a patch.
  updatePodcastByOmnyPlaylistId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePodcastByOmnyPlaylistIdInput!
  ): UpdatePodcastPayload

  # Deletes a single `Podcast` using its globally unique id.
  deletePodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePodcastInput!
  ): DeletePodcastPayload

  # Deletes a single `Podcast` using a unique key.
  deletePodcastById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePodcastByIdInput!
  ): DeletePodcastPayload

  # Deletes a single `Podcast` using a unique key.
  deletePodcastByOmnyPlaylistId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePodcastByOmnyPlaylistIdInput!
  ): DeletePodcastPayload

  # Creates a single `PodcastCategory`.
  createPodcastCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePodcastCategoryInput!
  ): CreatePodcastCategoryPayload

  # Updates a single `PodcastCategory` using its globally unique id and a patch.
  updatePodcastCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePodcastCategoryInput!
  ): UpdatePodcastCategoryPayload

  # Updates a single `PodcastCategory` using a unique key and a patch.
  updatePodcastCategoryById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePodcastCategoryByIdInput!
  ): UpdatePodcastCategoryPayload

  # Updates a single `PodcastCategory` using a unique key and a patch.
  updatePodcastCategoryByPodcastIdAndCategoryId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePodcastCategoryByPodcastIdAndCategoryIdInput!
  ): UpdatePodcastCategoryPayload

  # Deletes a single `PodcastCategory` using its globally unique id.
  deletePodcastCategory(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePodcastCategoryInput!
  ): DeletePodcastCategoryPayload

  # Deletes a single `PodcastCategory` using a unique key.
  deletePodcastCategoryById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePodcastCategoryByIdInput!
  ): DeletePodcastCategoryPayload

  # Deletes a single `PodcastCategory` using a unique key.
  deletePodcastCategoryByPodcastIdAndCategoryId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePodcastCategoryByPodcastIdAndCategoryIdInput!
  ): DeletePodcastCategoryPayload

  # Creates a single `PodcastClip`.
  createPodcastClip(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreatePodcastClipInput!
  ): CreatePodcastClipPayload

  # Updates a single `PodcastClip` using its globally unique id and a patch.
  updatePodcastClip(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePodcastClipInput!
  ): UpdatePodcastClipPayload

  # Updates a single `PodcastClip` using a unique key and a patch.
  updatePodcastClipById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePodcastClipByIdInput!
  ): UpdatePodcastClipPayload

  # Updates a single `PodcastClip` using a unique key and a patch.
  updatePodcastClipByPodcastIdAndClipId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdatePodcastClipByPodcastIdAndClipIdInput!
  ): UpdatePodcastClipPayload

  # Deletes a single `PodcastClip` using its globally unique id.
  deletePodcastClip(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePodcastClipInput!
  ): DeletePodcastClipPayload

  # Deletes a single `PodcastClip` using a unique key.
  deletePodcastClipById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePodcastClipByIdInput!
  ): DeletePodcastClipPayload

  # Deletes a single `PodcastClip` using a unique key.
  deletePodcastClipByPodcastIdAndClipId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeletePodcastClipByPodcastIdAndClipIdInput!
  ): DeletePodcastClipPayload

  # Creates a single `Show`.
  createShow(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateShowInput!
  ): CreateShowPayload

  # Updates a single `Show` using its globally unique id and a patch.
  updateShow(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowInput!
  ): UpdateShowPayload

  # Updates a single `Show` using a unique key and a patch.
  updateShowById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowByIdInput!
  ): UpdateShowPayload

  # Updates a single `Show` using a unique key and a patch.
  updateShowByProgramId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowByProgramIdInput!
  ): UpdateShowPayload

  # Deletes a single `Show` using its globally unique id.
  deleteShow(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowInput!
  ): DeleteShowPayload

  # Deletes a single `Show` using a unique key.
  deleteShowById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowByIdInput!
  ): DeleteShowPayload

  # Deletes a single `Show` using a unique key.
  deleteShowByProgramId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowByProgramIdInput!
  ): DeleteShowPayload

  # Creates a single `ShowModule`.
  createShowModule(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateShowModuleInput!
  ): CreateShowModulePayload

  # Updates a single `ShowModule` using its globally unique id and a patch.
  updateShowModule(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowModuleInput!
  ): UpdateShowModulePayload

  # Updates a single `ShowModule` using a unique key and a patch.
  updateShowModuleById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowModuleByIdInput!
  ): UpdateShowModulePayload

  # Deletes a single `ShowModule` using its globally unique id.
  deleteShowModule(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowModuleInput!
  ): DeleteShowModulePayload

  # Deletes a single `ShowModule` using a unique key.
  deleteShowModuleById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowModuleByIdInput!
  ): DeleteShowModulePayload

  # Creates a single `ShowModuleCustom`.
  createShowModuleCustom(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateShowModuleCustomInput!
  ): CreateShowModuleCustomPayload

  # Updates a single `ShowModuleCustom` using its globally unique id and a patch.
  updateShowModuleCustom(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowModuleCustomInput!
  ): UpdateShowModuleCustomPayload

  # Updates a single `ShowModuleCustom` using a unique key and a patch.
  updateShowModuleCustomById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowModuleCustomByIdInput!
  ): UpdateShowModuleCustomPayload

  # Deletes a single `ShowModuleCustom` using its globally unique id.
  deleteShowModuleCustom(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowModuleCustomInput!
  ): DeleteShowModuleCustomPayload

  # Deletes a single `ShowModuleCustom` using a unique key.
  deleteShowModuleCustomById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowModuleCustomByIdInput!
  ): DeleteShowModuleCustomPayload

  # Creates a single `ShowPlaylist`.
  createShowPlaylist(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateShowPlaylistInput!
  ): CreateShowPlaylistPayload

  # Updates a single `ShowPlaylist` using its globally unique id and a patch.
  updateShowPlaylist(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowPlaylistInput!
  ): UpdateShowPlaylistPayload

  # Updates a single `ShowPlaylist` using a unique key and a patch.
  updateShowPlaylistById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowPlaylistByIdInput!
  ): UpdateShowPlaylistPayload

  # Updates a single `ShowPlaylist` using a unique key and a patch.
  updateShowPlaylistByShowIdAndPlaylistId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowPlaylistByShowIdAndPlaylistIdInput!
  ): UpdateShowPlaylistPayload

  # Deletes a single `ShowPlaylist` using its globally unique id.
  deleteShowPlaylist(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowPlaylistInput!
  ): DeleteShowPlaylistPayload

  # Deletes a single `ShowPlaylist` using a unique key.
  deleteShowPlaylistById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowPlaylistByIdInput!
  ): DeleteShowPlaylistPayload

  # Deletes a single `ShowPlaylist` using a unique key.
  deleteShowPlaylistByShowIdAndPlaylistId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowPlaylistByShowIdAndPlaylistIdInput!
  ): DeleteShowPlaylistPayload

  # Creates a single `ShowPodcast`.
  createShowPodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateShowPodcastInput!
  ): CreateShowPodcastPayload

  # Updates a single `ShowPodcast` using its globally unique id and a patch.
  updateShowPodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowPodcastInput!
  ): UpdateShowPodcastPayload

  # Updates a single `ShowPodcast` using a unique key and a patch.
  updateShowPodcastById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowPodcastByIdInput!
  ): UpdateShowPodcastPayload

  # Updates a single `ShowPodcast` using a unique key and a patch.
  updateShowPodcastByShowIdAndPodcastId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateShowPodcastByShowIdAndPodcastIdInput!
  ): UpdateShowPodcastPayload

  # Deletes a single `ShowPodcast` using its globally unique id.
  deleteShowPodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowPodcastInput!
  ): DeleteShowPodcastPayload

  # Deletes a single `ShowPodcast` using a unique key.
  deleteShowPodcastById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowPodcastByIdInput!
  ): DeleteShowPodcastPayload

  # Deletes a single `ShowPodcast` using a unique key.
  deleteShowPodcastByShowIdAndPodcastId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteShowPodcastByShowIdAndPodcastIdInput!
  ): DeleteShowPodcastPayload

  # Creates a single `Song`.
  createSong(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateSongInput!
  ): CreateSongPayload

  # Updates a single `Song` using its globally unique id and a patch.
  updateSong(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSongInput!
  ): UpdateSongPayload

  # Updates a single `Song` using a unique key and a patch.
  updateSongById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSongByIdInput!
  ): UpdateSongPayload

  # Updates a single `Song` using a unique key and a patch.
  updateSongByUfid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSongByUfidInput!
  ): UpdateSongPayload

  # Deletes a single `Song` using its globally unique id.
  deleteSong(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSongInput!
  ): DeleteSongPayload

  # Deletes a single `Song` using a unique key.
  deleteSongById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSongByIdInput!
  ): DeleteSongPayload

  # Deletes a single `Song` using a unique key.
  deleteSongByUfid(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSongByUfidInput!
  ): DeleteSongPayload

  # Creates a single `SongPlay`.
  createSongPlay(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateSongPlayInput!
  ): CreateSongPlayPayload

  # Updates a single `SongPlay` using its globally unique id and a patch.
  updateSongPlay(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSongPlayInput!
  ): UpdateSongPlayPayload

  # Updates a single `SongPlay` using a unique key and a patch.
  updateSongPlayById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateSongPlayByIdInput!
  ): UpdateSongPlayPayload

  # Deletes a single `SongPlay` using its globally unique id.
  deleteSongPlay(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSongPlayInput!
  ): DeleteSongPlayPayload

  # Deletes a single `SongPlay` using a unique key.
  deleteSongPlayById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteSongPlayByIdInput!
  ): DeleteSongPlayPayload

  # Creates a single `Station`.
  createStation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateStationInput!
  ): CreateStationPayload

  # Updates a single `Station` using its globally unique id and a patch.
  updateStation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationInput!
  ): UpdateStationPayload

  # Updates a single `Station` using a unique key and a patch.
  updateStationById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationByIdInput!
  ): UpdateStationPayload

  # Updates a single `Station` using a unique key and a patch.
  updateStationByR20id(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationByR20idInput!
  ): UpdateStationPayload

  # Deletes a single `Station` using its globally unique id.
  deleteStation(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationInput!
  ): DeleteStationPayload

  # Deletes a single `Station` using a unique key.
  deleteStationById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationByIdInput!
  ): DeleteStationPayload

  # Deletes a single `Station` using a unique key.
  deleteStationByR20id(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationByR20idInput!
  ): DeleteStationPayload

  # Creates a single `StationGenre`.
  createStationGenre(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateStationGenreInput!
  ): CreateStationGenrePayload

  # Updates a single `StationGenre` using its globally unique id and a patch.
  updateStationGenre(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationGenreInput!
  ): UpdateStationGenrePayload

  # Updates a single `StationGenre` using a unique key and a patch.
  updateStationGenreById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationGenreByIdInput!
  ): UpdateStationGenrePayload

  # Updates a single `StationGenre` using a unique key and a patch.
  updateStationGenreByStationIdAndGenreId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationGenreByStationIdAndGenreIdInput!
  ): UpdateStationGenrePayload

  # Deletes a single `StationGenre` using its globally unique id.
  deleteStationGenre(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationGenreInput!
  ): DeleteStationGenrePayload

  # Deletes a single `StationGenre` using a unique key.
  deleteStationGenreById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationGenreByIdInput!
  ): DeleteStationGenrePayload

  # Deletes a single `StationGenre` using a unique key.
  deleteStationGenreByStationIdAndGenreId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationGenreByStationIdAndGenreIdInput!
  ): DeleteStationGenrePayload

  # Creates a single `StationModule`.
  createStationModule(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateStationModuleInput!
  ): CreateStationModulePayload

  # Updates a single `StationModule` using its globally unique id and a patch.
  updateStationModule(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationModuleInput!
  ): UpdateStationModulePayload

  # Updates a single `StationModule` using a unique key and a patch.
  updateStationModuleById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationModuleByIdInput!
  ): UpdateStationModulePayload

  # Deletes a single `StationModule` using its globally unique id.
  deleteStationModule(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationModuleInput!
  ): DeleteStationModulePayload

  # Deletes a single `StationModule` using a unique key.
  deleteStationModuleById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationModuleByIdInput!
  ): DeleteStationModulePayload

  # Creates a single `StationModuleCustom`.
  createStationModuleCustom(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateStationModuleCustomInput!
  ): CreateStationModuleCustomPayload

  # Updates a single `StationModuleCustom` using its globally unique id and a patch.
  updateStationModuleCustom(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationModuleCustomInput!
  ): UpdateStationModuleCustomPayload

  # Updates a single `StationModuleCustom` using a unique key and a patch.
  updateStationModuleCustomById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationModuleCustomByIdInput!
  ): UpdateStationModuleCustomPayload

  # Deletes a single `StationModuleCustom` using its globally unique id.
  deleteStationModuleCustom(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationModuleCustomInput!
  ): DeleteStationModuleCustomPayload

  # Deletes a single `StationModuleCustom` using a unique key.
  deleteStationModuleCustomById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationModuleCustomByIdInput!
  ): DeleteStationModuleCustomPayload

  # Creates a single `StationMount`.
  createStationMount(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateStationMountInput!
  ): CreateStationMountPayload

  # Updates a single `StationMount` using its globally unique id and a patch.
  updateStationMount(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationMountInput!
  ): UpdateStationMountPayload

  # Updates a single `StationMount` using a unique key and a patch.
  updateStationMountById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationMountByIdInput!
  ): UpdateStationMountPayload

  # Deletes a single `StationMount` using its globally unique id.
  deleteStationMount(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationMountInput!
  ): DeleteStationMountPayload

  # Deletes a single `StationMount` using a unique key.
  deleteStationMountById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationMountByIdInput!
  ): DeleteStationMountPayload

  # Creates a single `StationPlaylist`.
  createStationPlaylist(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateStationPlaylistInput!
  ): CreateStationPlaylistPayload

  # Updates a single `StationPlaylist` using its globally unique id and a patch.
  updateStationPlaylist(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationPlaylistInput!
  ): UpdateStationPlaylistPayload

  # Updates a single `StationPlaylist` using a unique key and a patch.
  updateStationPlaylistById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationPlaylistByIdInput!
  ): UpdateStationPlaylistPayload

  # Updates a single `StationPlaylist` using a unique key and a patch.
  updateStationPlaylistByStationIdAndPlaylistId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationPlaylistByStationIdAndPlaylistIdInput!
  ): UpdateStationPlaylistPayload

  # Deletes a single `StationPlaylist` using its globally unique id.
  deleteStationPlaylist(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationPlaylistInput!
  ): DeleteStationPlaylistPayload

  # Deletes a single `StationPlaylist` using a unique key.
  deleteStationPlaylistById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationPlaylistByIdInput!
  ): DeleteStationPlaylistPayload

  # Deletes a single `StationPlaylist` using a unique key.
  deleteStationPlaylistByStationIdAndPlaylistId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationPlaylistByStationIdAndPlaylistIdInput!
  ): DeleteStationPlaylistPayload

  # Creates a single `StationPodcast`.
  createStationPodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateStationPodcastInput!
  ): CreateStationPodcastPayload

  # Updates a single `StationPodcast` using its globally unique id and a patch.
  updateStationPodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationPodcastInput!
  ): UpdateStationPodcastPayload

  # Updates a single `StationPodcast` using a unique key and a patch.
  updateStationPodcastById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationPodcastByIdInput!
  ): UpdateStationPodcastPayload

  # Updates a single `StationPodcast` using a unique key and a patch.
  updateStationPodcastByStationIdAndPodcastId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationPodcastByStationIdAndPodcastIdInput!
  ): UpdateStationPodcastPayload

  # Deletes a single `StationPodcast` using its globally unique id.
  deleteStationPodcast(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationPodcastInput!
  ): DeleteStationPodcastPayload

  # Deletes a single `StationPodcast` using a unique key.
  deleteStationPodcastById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationPodcastByIdInput!
  ): DeleteStationPodcastPayload

  # Deletes a single `StationPodcast` using a unique key.
  deleteStationPodcastByStationIdAndPodcastId(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationPodcastByStationIdAndPodcastIdInput!
  ): DeleteStationPodcastPayload

  # Creates a single `StationShow`.
  createStationShow(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateStationShowInput!
  ): CreateStationShowPayload

  # Updates a single `StationShow` using its globally unique id and a patch.
  updateStationShow(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationShowInput!
  ): UpdateStationShowPayload

  # Updates a single `StationShow` using a unique key and a patch.
  updateStationShowById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationShowByIdInput!
  ): UpdateStationShowPayload

  # Deletes a single `StationShow` using its globally unique id.
  deleteStationShow(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationShowInput!
  ): DeleteStationShowPayload

  # Deletes a single `StationShow` using a unique key.
  deleteStationShowById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationShowByIdInput!
  ): DeleteStationShowPayload

  # Creates a single `StationShowSchedule`.
  createStationShowSchedule(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateStationShowScheduleInput!
  ): CreateStationShowSchedulePayload

  # Updates a single `StationShowSchedule` using its globally unique id and a patch.
  updateStationShowSchedule(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationShowScheduleInput!
  ): UpdateStationShowSchedulePayload

  # Updates a single `StationShowSchedule` using a unique key and a patch.
  updateStationShowScheduleById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationShowScheduleByIdInput!
  ): UpdateStationShowSchedulePayload

  # Deletes a single `StationShowSchedule` using its globally unique id.
  deleteStationShowSchedule(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationShowScheduleInput!
  ): DeleteStationShowSchedulePayload

  # Deletes a single `StationShowSchedule` using a unique key.
  deleteStationShowScheduleById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationShowScheduleByIdInput!
  ): DeleteStationShowSchedulePayload

  # Creates a single `StationStream`.
  createStationStream(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: CreateStationStreamInput!
  ): CreateStationStreamPayload

  # Updates a single `StationStream` using its globally unique id and a patch.
  updateStationStream(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationStreamInput!
  ): UpdateStationStreamPayload

  # Updates a single `StationStream` using a unique key and a patch.
  updateStationStreamById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: UpdateStationStreamByIdInput!
  ): UpdateStationStreamPayload

  # Deletes a single `StationStream` using its globally unique id.
  deleteStationStream(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationStreamInput!
  ): DeleteStationStreamPayload

  # Deletes a single `StationStream` using a unique key.
  deleteStationStreamById(
    # The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    input: DeleteStationStreamByIdInput!
  ): DeleteStationStreamPayload
}

# An object with a globally unique `ID`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

type Playlist implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  omnyPlaylistId: String!
  title: String!
  description: String
  heroImage: String
  createdDate: Datetime!
  modifiedDate: Datetime!
  image: String

  # Reads and enables pagination through a set of `PlaylistClip`.
  playlistClipsByPlaylistId(
    # The method to use when ordering `PlaylistClip`.
    orderBy: PlaylistClipsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PlaylistClipCondition
  ): PlaylistClipsConnection

  # Reads and enables pagination through a set of `ShowPlaylist`.
  showPlaylistsByPlaylistId(
    # The method to use when ordering `ShowPlaylist`.
    orderBy: ShowPlaylistsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ShowPlaylistCondition
  ): ShowPlaylistsConnection

  # Reads and enables pagination through a set of `StationPlaylist`.
  stationPlaylistsByPlaylistId(
    # The method to use when ordering `StationPlaylist`.
    orderBy: StationPlaylistsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationPlaylistCondition
  ): StationPlaylistsConnection
}

type PlaylistClip implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  playlistId: Int!
  clipId: Int!
  sortOrder: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Playlist` that is related to this `PlaylistClip`.
  playlistByPlaylistId: Playlist

  # Reads a single `Clip` that is related to this `PlaylistClip`.
  clipByClipId: Clip
}

# A condition to be used against `PlaylistClip` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input PlaylistClipCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `playlistId` field.
  playlistId: Int

  # Checks for equality with the object’s `clipId` field.
  clipId: Int

  # Checks for equality with the object’s `sortOrder` field.
  sortOrder: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input PlaylistClipInput {
  id: Int
  playlistId: Int!
  clipId: Int!
  sortOrder: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `PlaylistClip`. Fields that are set will be updated.
input PlaylistClipPatch {
  id: Int
  playlistId: Int
  clipId: Int
  sortOrder: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `PlaylistClip` values.
type PlaylistClipsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PlaylistClip` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PlaylistClip` and cursor to aid in pagination.
  edges: [PlaylistClipsEdge]

  # A list of `PlaylistClip` objects.
  nodes: [PlaylistClip!]
}

# A `PlaylistClip` edge in the connection.
type PlaylistClipsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PlaylistClip` at the end of the edge.
  node: PlaylistClip!
}

# Methods to use when ordering `PlaylistClip`.
enum PlaylistClipsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  PLAYLIST_ID_ASC
  PLAYLIST_ID_DESC
  CLIP_ID_ASC
  CLIP_ID_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

# A condition to be used against `Playlist` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input PlaylistCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `omnyPlaylistId` field.
  omnyPlaylistId: String

  # Checks for equality with the object’s `title` field.
  title: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `heroImage` field.
  heroImage: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime

  # Checks for equality with the object’s `image` field.
  image: String
}

input PlaylistInput {
  id: Int
  omnyPlaylistId: String!
  title: String!
  description: String
  heroImage: String
  createdDate: Datetime
  modifiedDate: Datetime
  image: String
}

# Represents an update to a `Playlist`. Fields that are set will be updated.
input PlaylistPatch {
  id: Int
  omnyPlaylistId: String
  title: String
  description: String
  heroImage: String
  createdDate: Datetime
  modifiedDate: Datetime
  image: String
}

# A connection to a list of `Playlist` values.
type PlaylistsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Playlist` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Playlist` and cursor to aid in pagination.
  edges: [PlaylistsEdge]

  # A list of `Playlist` objects.
  nodes: [Playlist!]
}

# A `Playlist` edge in the connection.
type PlaylistsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Playlist` at the end of the edge.
  node: Playlist!
}

# Methods to use when ordering `Playlist`.
enum PlaylistsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  OMNY_PLAYLIST_ID_ASC
  OMNY_PLAYLIST_ID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  HERO_IMAGE_ASC
  HERO_IMAGE_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
  IMAGE_ASC
  IMAGE_DESC
}

type Podcast implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  title: String
  siteUrl: String
  heroImage: String
  image: String
  rssFeed: String
  createdDate: Datetime!
  modifiedDate: Datetime!
  popularity: Int!
  itunesUrl: String
  description: String
  omnyPlaylistId: String

  # Reads and enables pagination through a set of `FeaturedPodcast`.
  featuredPodcastsByPodcastId(
    # The method to use when ordering `FeaturedPodcast`.
    orderBy: FeaturedPodcastsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FeaturedPodcastCondition
  ): FeaturedPodcastsConnection

  # Reads and enables pagination through a set of `PodcastCategory`.
  podcastCategoriesByPodcastId(
    # The method to use when ordering `PodcastCategory`.
    orderBy: PodcastCategoriesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PodcastCategoryCondition
  ): PodcastCategoriesConnection

  # Reads and enables pagination through a set of `PodcastClip`.
  podcastClipsByPodcastId(
    # The method to use when ordering `PodcastClip`.
    orderBy: PodcastClipsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PodcastClipCondition
  ): PodcastClipsConnection

  # Reads and enables pagination through a set of `ShowPodcast`.
  showPodcastsByPodcastId(
    # The method to use when ordering `ShowPodcast`.
    orderBy: ShowPodcastsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ShowPodcastCondition
  ): ShowPodcastsConnection

  # Reads and enables pagination through a set of `StationPodcast`.
  stationPodcastsByPodcastId(
    # The method to use when ordering `StationPodcast`.
    orderBy: StationPodcastsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationPodcastCondition
  ): StationPodcastsConnection
}

# A connection to a list of `PodcastCategory` values.
type PodcastCategoriesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PodcastCategory` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PodcastCategory` and cursor to aid in pagination.
  edges: [PodcastCategoriesEdge]

  # A list of `PodcastCategory` objects.
  nodes: [PodcastCategory!]
}

# A `PodcastCategory` edge in the connection.
type PodcastCategoriesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PodcastCategory` at the end of the edge.
  node: PodcastCategory!
}

# Methods to use when ordering `PodcastCategory`.
enum PodcastCategoriesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  PODCAST_ID_ASC
  PODCAST_ID_DESC
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

type PodcastCategory implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  podcastId: Int!
  categoryId: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Podcast` that is related to this `PodcastCategory`.
  podcastByPodcastId: Podcast

  # Reads a single `Category` that is related to this `PodcastCategory`.
  categoryByCategoryId: Category
}

# A condition to be used against `PodcastCategory` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input PodcastCategoryCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `podcastId` field.
  podcastId: Int

  # Checks for equality with the object’s `categoryId` field.
  categoryId: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input PodcastCategoryInput {
  id: Int
  podcastId: Int!
  categoryId: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `PodcastCategory`. Fields that are set will be updated.
input PodcastCategoryPatch {
  id: Int
  podcastId: Int
  categoryId: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

type PodcastClip implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  podcastId: Int!
  clipId: Int!
  sortOrder: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Podcast` that is related to this `PodcastClip`.
  podcastByPodcastId: Podcast

  # Reads a single `Clip` that is related to this `PodcastClip`.
  clipByClipId: Clip
}

# A condition to be used against `PodcastClip` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input PodcastClipCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `podcastId` field.
  podcastId: Int

  # Checks for equality with the object’s `clipId` field.
  clipId: Int

  # Checks for equality with the object’s `sortOrder` field.
  sortOrder: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input PodcastClipInput {
  id: Int
  podcastId: Int!
  clipId: Int!
  sortOrder: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `PodcastClip`. Fields that are set will be updated.
input PodcastClipPatch {
  id: Int
  podcastId: Int
  clipId: Int
  sortOrder: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `PodcastClip` values.
type PodcastClipsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PodcastClip` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PodcastClip` and cursor to aid in pagination.
  edges: [PodcastClipsEdge]

  # A list of `PodcastClip` objects.
  nodes: [PodcastClip!]
}

# A `PodcastClip` edge in the connection.
type PodcastClipsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PodcastClip` at the end of the edge.
  node: PodcastClip!
}

# Methods to use when ordering `PodcastClip`.
enum PodcastClipsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  PODCAST_ID_ASC
  PODCAST_ID_DESC
  CLIP_ID_ASC
  CLIP_ID_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

# A condition to be used against `Podcast` object types. All fields are tested for equality and combined with a logical ‘and.’
input PodcastCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `title` field.
  title: String

  # Checks for equality with the object’s `siteUrl` field.
  siteUrl: String

  # Checks for equality with the object’s `heroImage` field.
  heroImage: String

  # Checks for equality with the object’s `image` field.
  image: String

  # Checks for equality with the object’s `rssFeed` field.
  rssFeed: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime

  # Checks for equality with the object’s `popularity` field.
  popularity: Int

  # Checks for equality with the object’s `itunesUrl` field.
  itunesUrl: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `omnyPlaylistId` field.
  omnyPlaylistId: String
}

input PodcastInput {
  id: Int
  title: String
  siteUrl: String
  heroImage: String
  image: String
  rssFeed: String
  createdDate: Datetime
  modifiedDate: Datetime
  popularity: Int
  itunesUrl: String
  description: String
  omnyPlaylistId: String
}

# Represents an update to a `Podcast`. Fields that are set will be updated.
input PodcastPatch {
  id: Int
  title: String
  siteUrl: String
  heroImage: String
  image: String
  rssFeed: String
  createdDate: Datetime
  modifiedDate: Datetime
  popularity: Int
  itunesUrl: String
  description: String
  omnyPlaylistId: String
}

# A connection to a list of `Podcast` values.
type PodcastsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Podcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Podcast` and cursor to aid in pagination.
  edges: [PodcastsEdge]

  # A list of `Podcast` objects.
  nodes: [Podcast!]
}

# A `Podcast` edge in the connection.
type PodcastsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Podcast` at the end of the edge.
  node: Podcast!
}

# Methods to use when ordering `Podcast`.
enum PodcastsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  TITLE_ASC
  TITLE_DESC
  SITE_URL_ASC
  SITE_URL_DESC
  HERO_IMAGE_ASC
  HERO_IMAGE_DESC
  IMAGE_ASC
  IMAGE_DESC
  RSS_FEED_ASC
  RSS_FEED_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
  POPULARITY_ASC
  POPULARITY_DESC
  ITUNES_URL_ASC
  ITUNES_URL_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  OMNY_PLAYLIST_ID_ASC
  OMNY_PLAYLIST_ID_DESC
}

# A connection to a list of `Podcast` values.
type PopularPodcastsByCategoryIdConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Podcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Podcast` and cursor to aid in pagination.
  edges: [PopularPodcastsByCategoryIdEdge]

  # A list of `Podcast` objects.
  nodes: [Podcast]
}

# A `Podcast` edge in the connection.
type PopularPodcastsByCategoryIdEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Podcast` at the end of the edge.
  node: Podcast
}

# Methods to use when ordering `Podcast`.
enum PopularPodcastsByCategoryIdOrderBy {
  NATURAL
}

# A connection to a list of `Podcast` values.
type PopularPodcastsByCategorySlugConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Podcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Podcast` and cursor to aid in pagination.
  edges: [PopularPodcastsByCategorySlugEdge]

  # A list of `Podcast` objects.
  nodes: [Podcast]
}

# A `Podcast` edge in the connection.
type PopularPodcastsByCategorySlugEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Podcast` at the end of the edge.
  node: Podcast
}

# Methods to use when ordering `Podcast`.
enum PopularPodcastsByCategorySlugOrderBy {
  NATURAL
}

# A connection to a list of `Podcast` values.
type PopularPodcastsByMarketIdConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Podcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Podcast` and cursor to aid in pagination.
  edges: [PopularPodcastsByMarketIdEdge]

  # A list of `Podcast` objects.
  nodes: [Podcast]
}

# A `Podcast` edge in the connection.
type PopularPodcastsByMarketIdEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Podcast` at the end of the edge.
  node: Podcast
}

# Methods to use when ordering `Podcast`.
enum PopularPodcastsByMarketIdOrderBy {
  NATURAL
}

# A connection to a list of `Podcast` values.
type PopularPodcastsByMarketIdsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Podcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Podcast` and cursor to aid in pagination.
  edges: [PopularPodcastsByMarketIdsEdge]

  # A list of `Podcast` objects.
  nodes: [Podcast]
}

# A `Podcast` edge in the connection.
type PopularPodcastsByMarketIdsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Podcast` at the end of the edge.
  node: Podcast
}

# Methods to use when ordering `Podcast`.
enum PopularPodcastsByMarketIdsOrderBy {
  NATURAL
}

# A connection to a list of `Station` values.
type PopularStationsByGenreIdConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Station` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Station` and cursor to aid in pagination.
  edges: [PopularStationsByGenreIdEdge]

  # A list of `Station` objects.
  nodes: [Station]
}

# A `Station` edge in the connection.
type PopularStationsByGenreIdEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Station` at the end of the edge.
  node: Station
}

# Methods to use when ordering `Station`.
enum PopularStationsByGenreIdOrderBy {
  NATURAL
}

# A connection to a list of `Station` values.
type PopularStationsByGenreSlugConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Station` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Station` and cursor to aid in pagination.
  edges: [PopularStationsByGenreSlugEdge]

  # A list of `Station` objects.
  nodes: [Station]
}

# A `Station` edge in the connection.
type PopularStationsByGenreSlugEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Station` at the end of the edge.
  node: Station
}

# Methods to use when ordering `Station`.
enum PopularStationsByGenreSlugOrderBy {
  NATURAL
}

# A connection to a list of `Station` values.
type PopularStationsByMarketIdConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Station` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Station` and cursor to aid in pagination.
  edges: [PopularStationsByMarketIdEdge]

  # A list of `Station` objects.
  nodes: [Station]
}

# A `Station` edge in the connection.
type PopularStationsByMarketIdEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Station` at the end of the edge.
  node: Station
}

# Methods to use when ordering `Station`.
enum PopularStationsByMarketIdOrderBy {
  NATURAL
}

# A connection to a list of `Station` values.
type PopularStationsByMarketIdsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Station` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Station` and cursor to aid in pagination.
  edges: [PopularStationsByMarketIdsEdge]

  # A list of `Station` objects.
  nodes: [Station]
}

# A `Station` edge in the connection.
type PopularStationsByMarketIdsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Station` at the end of the edge.
  node: Station
}

# Methods to use when ordering `Station`.
enum PopularStationsByMarketIdsOrderBy {
  NATURAL
}

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Fetches an object given its globally unique `ID`.
  node(
    # The globally unique `ID`.
    nodeId: ID!
  ): Node
  crypt(arg0: String!, arg1: String!): String
  dearmor(arg0: String!): String
  decrypt(arg0: String!, arg1: String!, arg2: String!): String
  decryptIv(arg0: String!, arg1: String!, arg2: String!, arg3: String!): String
  encrypt(arg0: String!, arg1: String!, arg2: String!): String
  encryptIv(arg0: String!, arg1: String!, arg2: String!, arg3: String!): String
  pgpKeyId(arg0: String!): String

  # Reads and enables pagination through a set of `Podcast`.
  popularPodcastsByCategoryId(
    # The method to use when ordering `Podcast`.
    orderBy: PopularPodcastsByCategoryIdOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    id: Int
  ): PopularPodcastsByCategoryIdConnection

  # Reads and enables pagination through a set of `Podcast`.
  popularPodcastsByCategorySlug(
    # The method to use when ordering `Podcast`.
    orderBy: PopularPodcastsByCategorySlugOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    slug: String
  ): PopularPodcastsByCategorySlugConnection

  # Reads and enables pagination through a set of `Podcast`.
  popularPodcastsByMarketId(
    # The method to use when ordering `Podcast`.
    orderBy: PopularPodcastsByMarketIdOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    id: Int
  ): PopularPodcastsByMarketIdConnection

  # Reads and enables pagination through a set of `Podcast`.
  popularPodcastsByMarketIds(
    # The method to use when ordering `Podcast`.
    orderBy: PopularPodcastsByMarketIdsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    ids: [Int]
  ): PopularPodcastsByMarketIdsConnection

  # Reads and enables pagination through a set of `Station`.
  popularStationsByGenreId(
    # The method to use when ordering `Station`.
    orderBy: PopularStationsByGenreIdOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    id: Int
  ): PopularStationsByGenreIdConnection

  # Reads and enables pagination through a set of `Station`.
  popularStationsByGenreSlug(
    # The method to use when ordering `Station`.
    orderBy: PopularStationsByGenreSlugOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    slug: String
  ): PopularStationsByGenreSlugConnection

  # Reads and enables pagination through a set of `Station`.
  popularStationsByMarketId(
    # The method to use when ordering `Station`.
    orderBy: PopularStationsByMarketIdOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    id: Int
  ): PopularStationsByMarketIdConnection

  # Reads and enables pagination through a set of `Station`.
  popularStationsByMarketIds(
    # The method to use when ordering `Station`.
    orderBy: PopularStationsByMarketIdsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    ids: [Int]
  ): PopularStationsByMarketIdsConnection

  # Reads and enables pagination through a set of `Podcast`.
  recommendedPodcastsByMarketId(
    # The method to use when ordering `Podcast`.
    orderBy: RecommendedPodcastsByMarketIdOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    id: Int
  ): RecommendedPodcastsByMarketIdConnection

  # Reads and enables pagination through a set of `Podcast`.
  recommendedPodcastsByMarketIds(
    # The method to use when ordering `Podcast`.
    orderBy: RecommendedPodcastsByMarketIdsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    ids: [Int]
  ): RecommendedPodcastsByMarketIdsConnection

  # Reads and enables pagination through a set of `Station`.
  recommendedStationsByMarketId(
    # The method to use when ordering `Station`.
    orderBy: RecommendedStationsByMarketIdOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    id: Int
  ): RecommendedStationsByMarketIdConnection

  # Reads and enables pagination through a set of `Station`.
  recommendedStationsByMarketIds(
    # The method to use when ordering `Station`.
    orderBy: RecommendedStationsByMarketIdsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    ids: [Int]
  ): RecommendedStationsByMarketIdsConnection

  # Reads and enables pagination through a set of `Clip`.
  searchAudioClips(
    # The method to use when ordering `Clip`.
    orderBy: SearchAudioClipsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    search: String
  ): SearchAudioClipsConnection

  # Reads and enables pagination through a set of `Clip`.
  searchPodcastEpisodes(
    # The method to use when ordering `Clip`.
    orderBy: SearchPodcastEpisodesOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    search: String
  ): SearchPodcastEpisodesConnection

  # Reads and enables pagination through a set of `Podcast`.
  searchPodcasts(
    # The method to use when ordering `Podcast`.
    orderBy: SearchPodcastsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    search: String
  ): SearchPodcastsConnection

  # Reads and enables pagination through a set of `Station`.
  searchStations(
    # The method to use when ordering `Station`.
    orderBy: SearchStationsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    search: String
  ): SearchStationsConnection

  # Reads and enables pagination through a set of `Clip`.
  sortedPodcastClips(
    # The method to use when ordering `Clip`.
    orderBy: SortedPodcastClipsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
    id: Int
  ): SortedPodcastClipsConnection

  # Reads and enables pagination through a set of `AdminUserPerm`.
  allAdminUserPerms(
    # The method to use when ordering `AdminUserPerm`.
    orderBy: AdminUserPermsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AdminUserPermCondition
  ): AdminUserPermsConnection

  # Reads a single `AdminUserPerm` using its globally unique `ID`.
  adminUserPerm(
    # The globally unique `ID` to be used in selecting a single `AdminUserPerm`.
    nodeId: ID!
  ): AdminUserPerm
  adminUserPermByUserIdAndPageNameAndPermName(userId: Int!, pageName: String!, permName: String!): AdminUserPerm

  # Reads and enables pagination through a set of `AdminUser`.
  allAdminUsers(
    # The method to use when ordering `AdminUser`.
    orderBy: AdminUsersOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AdminUserCondition
  ): AdminUsersConnection

  # Reads a single `AdminUser` using its globally unique `ID`.
  adminUser(
    # The globally unique `ID` to be used in selecting a single `AdminUser`.
    nodeId: ID!
  ): AdminUser
  adminUserByUserId(userId: Int!): AdminUser

  # Reads and enables pagination through a set of `Category`.
  allCategories(
    # The method to use when ordering `Category`.
    orderBy: CategoriesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: CategoryCondition
  ): CategoriesConnection

  # Reads a single `Category` using its globally unique `ID`.
  category(
    # The globally unique `ID` to be used in selecting a single `Category`.
    nodeId: ID!
  ): Category
  categoryById(id: Int!): Category
  categoryByName(name: String!): Category
  categoryBySlug(slug: String!): Category

  # Reads and enables pagination through a set of `Clip`.
  allClips(
    # The method to use when ordering `Clip`.
    orderBy: ClipsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ClipCondition
  ): ClipsConnection

  # Reads a single `Clip` using its globally unique `ID`.
  clip(
    # The globally unique `ID` to be used in selecting a single `Clip`.
    nodeId: ID!
  ): Clip
  clipById(id: Int!): Clip
  clipByOmnyClipId(omnyClipId: String!): Clip

  # Reads and enables pagination through a set of `FeaturedPodcast`.
  allFeaturedPodcasts(
    # The method to use when ordering `FeaturedPodcast`.
    orderBy: FeaturedPodcastsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FeaturedPodcastCondition
  ): FeaturedPodcastsConnection

  # Reads a single `FeaturedPodcast` using its globally unique `ID`.
  featuredPodcast(
    # The globally unique `ID` to be used in selecting a single `FeaturedPodcast`.
    nodeId: ID!
  ): FeaturedPodcast
  featuredPodcastById(id: Int!): FeaturedPodcast
  featuredPodcastByPodcastIdAndMarketId(podcastId: Int!, marketId: Int!): FeaturedPodcast

  # Reads and enables pagination through a set of `FeaturedStation`.
  allFeaturedStations(
    # The method to use when ordering `FeaturedStation`.
    orderBy: FeaturedStationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FeaturedStationCondition
  ): FeaturedStationsConnection

  # Reads a single `FeaturedStation` using its globally unique `ID`.
  featuredStation(
    # The globally unique `ID` to be used in selecting a single `FeaturedStation`.
    nodeId: ID!
  ): FeaturedStation
  featuredStationById(id: Int!): FeaturedStation
  featuredStationByStationIdAndMarketId(stationId: Int!, marketId: Int!): FeaturedStation

  # Reads and enables pagination through a set of `Genre`.
  allGenres(
    # The method to use when ordering `Genre`.
    orderBy: GenresOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: GenreCondition
  ): GenresConnection

  # Reads a single `Genre` using its globally unique `ID`.
  genre(
    # The globally unique `ID` to be used in selecting a single `Genre`.
    nodeId: ID!
  ): Genre
  genreById(id: Int!): Genre
  genreByName(name: String!): Genre
  genreBySlug(slug: String!): Genre

  # Reads and enables pagination through a set of `Market`.
  allMarkets(
    # The method to use when ordering `Market`.
    orderBy: MarketsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: MarketCondition
  ): MarketsConnection

  # Reads a single `Market` using its globally unique `ID`.
  market(
    # The globally unique `ID` to be used in selecting a single `Market`.
    nodeId: ID!
  ): Market
  marketById(id: Int!): Market
  marketByName(name: String!): Market

  # Reads and enables pagination through a set of `Playlist`.
  allPlaylists(
    # The method to use when ordering `Playlist`.
    orderBy: PlaylistsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PlaylistCondition
  ): PlaylistsConnection

  # Reads a single `Playlist` using its globally unique `ID`.
  playlist(
    # The globally unique `ID` to be used in selecting a single `Playlist`.
    nodeId: ID!
  ): Playlist
  playlistById(id: Int!): Playlist
  playlistByOmnyPlaylistId(omnyPlaylistId: String!): Playlist

  # Reads and enables pagination through a set of `PlaylistClip`.
  allPlaylistClips(
    # The method to use when ordering `PlaylistClip`.
    orderBy: PlaylistClipsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PlaylistClipCondition
  ): PlaylistClipsConnection

  # Reads a single `PlaylistClip` using its globally unique `ID`.
  playlistClip(
    # The globally unique `ID` to be used in selecting a single `PlaylistClip`.
    nodeId: ID!
  ): PlaylistClip
  playlistClipById(id: Int!): PlaylistClip
  playlistClipByPlaylistIdAndClipId(playlistId: Int!, clipId: Int!): PlaylistClip

  # Reads and enables pagination through a set of `Podcast`.
  allPodcasts(
    # The method to use when ordering `Podcast`.
    orderBy: PodcastsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PodcastCondition
  ): PodcastsConnection

  # Reads a single `Podcast` using its globally unique `ID`.
  podcast(
    # The globally unique `ID` to be used in selecting a single `Podcast`.
    nodeId: ID!
  ): Podcast
  podcastById(id: Int!): Podcast
  podcastByOmnyPlaylistId(omnyPlaylistId: String!): Podcast

  # Reads and enables pagination through a set of `PodcastCategory`.
  allPodcastCategories(
    # The method to use when ordering `PodcastCategory`.
    orderBy: PodcastCategoriesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PodcastCategoryCondition
  ): PodcastCategoriesConnection

  # Reads a single `PodcastCategory` using its globally unique `ID`.
  podcastCategory(
    # The globally unique `ID` to be used in selecting a single `PodcastCategory`.
    nodeId: ID!
  ): PodcastCategory
  podcastCategoryById(id: Int!): PodcastCategory
  podcastCategoryByPodcastIdAndCategoryId(podcastId: Int!, categoryId: Int!): PodcastCategory

  # Reads and enables pagination through a set of `PodcastClip`.
  allPodcastClips(
    # The method to use when ordering `PodcastClip`.
    orderBy: PodcastClipsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PodcastClipCondition
  ): PodcastClipsConnection

  # Reads a single `PodcastClip` using its globally unique `ID`.
  podcastClip(
    # The globally unique `ID` to be used in selecting a single `PodcastClip`.
    nodeId: ID!
  ): PodcastClip
  podcastClipById(id: Int!): PodcastClip
  podcastClipByPodcastIdAndClipId(podcastId: Int!, clipId: Int!): PodcastClip

  # Reads and enables pagination through a set of `Show`.
  allShows(
    # The method to use when ordering `Show`.
    orderBy: ShowsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ShowCondition
  ): ShowsConnection

  # Reads a single `Show` using its globally unique `ID`.
  show(
    # The globally unique `ID` to be used in selecting a single `Show`.
    nodeId: ID!
  ): Show
  showById(id: Int!): Show
  showByProgramId(programId: String!): Show

  # Reads and enables pagination through a set of `ShowModule`.
  allShowModules(
    # The method to use when ordering `ShowModule`.
    orderBy: ShowModulesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ShowModuleCondition
  ): ShowModulesConnection

  # Reads a single `ShowModule` using its globally unique `ID`.
  showModule(
    # The globally unique `ID` to be used in selecting a single `ShowModule`.
    nodeId: ID!
  ): ShowModule
  showModuleById(id: Int!): ShowModule

  # Reads and enables pagination through a set of `ShowModuleCustom`.
  allShowModuleCustoms(
    # The method to use when ordering `ShowModuleCustom`.
    orderBy: ShowModuleCustomsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ShowModuleCustomCondition
  ): ShowModuleCustomsConnection

  # Reads a single `ShowModuleCustom` using its globally unique `ID`.
  showModuleCustom(
    # The globally unique `ID` to be used in selecting a single `ShowModuleCustom`.
    nodeId: ID!
  ): ShowModuleCustom
  showModuleCustomById(id: Int!): ShowModuleCustom

  # Reads and enables pagination through a set of `ShowPlaylist`.
  allShowPlaylists(
    # The method to use when ordering `ShowPlaylist`.
    orderBy: ShowPlaylistsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ShowPlaylistCondition
  ): ShowPlaylistsConnection

  # Reads a single `ShowPlaylist` using its globally unique `ID`.
  showPlaylist(
    # The globally unique `ID` to be used in selecting a single `ShowPlaylist`.
    nodeId: ID!
  ): ShowPlaylist
  showPlaylistById(id: Int!): ShowPlaylist
  showPlaylistByShowIdAndPlaylistId(showId: Int!, playlistId: Int!): ShowPlaylist

  # Reads and enables pagination through a set of `ShowPodcast`.
  allShowPodcasts(
    # The method to use when ordering `ShowPodcast`.
    orderBy: ShowPodcastsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ShowPodcastCondition
  ): ShowPodcastsConnection

  # Reads a single `ShowPodcast` using its globally unique `ID`.
  showPodcast(
    # The globally unique `ID` to be used in selecting a single `ShowPodcast`.
    nodeId: ID!
  ): ShowPodcast
  showPodcastById(id: Int!): ShowPodcast
  showPodcastByShowIdAndPodcastId(showId: Int!, podcastId: Int!): ShowPodcast

  # Reads and enables pagination through a set of `Song`.
  allSongs(
    # The method to use when ordering `Song`.
    orderBy: SongsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SongCondition
  ): SongsConnection

  # Reads a single `Song` using its globally unique `ID`.
  song(
    # The globally unique `ID` to be used in selecting a single `Song`.
    nodeId: ID!
  ): Song
  songById(id: Int!): Song
  songByUfid(ufid: String!): Song

  # Reads and enables pagination through a set of `SongPlay`.
  allSongPlays(
    # The method to use when ordering `SongPlay`.
    orderBy: SongPlaysOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SongPlayCondition
  ): SongPlaysConnection

  # Reads a single `SongPlay` using its globally unique `ID`.
  songPlay(
    # The globally unique `ID` to be used in selecting a single `SongPlay`.
    nodeId: ID!
  ): SongPlay
  songPlayById(id: Int!): SongPlay

  # Reads and enables pagination through a set of `Station`.
  allStations(
    # The method to use when ordering `Station`.
    orderBy: StationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationCondition
  ): StationsConnection

  # Reads a single `Station` using its globally unique `ID`.
  station(
    # The globally unique `ID` to be used in selecting a single `Station`.
    nodeId: ID!
  ): Station
  stationById(id: Int!): Station
  stationByR20id(r20id: Int!): Station

  # Reads and enables pagination through a set of `StationGenre`.
  allStationGenres(
    # The method to use when ordering `StationGenre`.
    orderBy: StationGenresOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationGenreCondition
  ): StationGenresConnection

  # Reads a single `StationGenre` using its globally unique `ID`.
  stationGenre(
    # The globally unique `ID` to be used in selecting a single `StationGenre`.
    nodeId: ID!
  ): StationGenre
  stationGenreById(id: Int!): StationGenre
  stationGenreByStationIdAndGenreId(stationId: Int!, genreId: Int!): StationGenre

  # Reads and enables pagination through a set of `StationModule`.
  allStationModules(
    # The method to use when ordering `StationModule`.
    orderBy: StationModulesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationModuleCondition
  ): StationModulesConnection

  # Reads a single `StationModule` using its globally unique `ID`.
  stationModule(
    # The globally unique `ID` to be used in selecting a single `StationModule`.
    nodeId: ID!
  ): StationModule
  stationModuleById(id: Int!): StationModule

  # Reads and enables pagination through a set of `StationModuleCustom`.
  allStationModuleCustoms(
    # The method to use when ordering `StationModuleCustom`.
    orderBy: StationModuleCustomsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationModuleCustomCondition
  ): StationModuleCustomsConnection

  # Reads a single `StationModuleCustom` using its globally unique `ID`.
  stationModuleCustom(
    # The globally unique `ID` to be used in selecting a single `StationModuleCustom`.
    nodeId: ID!
  ): StationModuleCustom
  stationModuleCustomById(id: Int!): StationModuleCustom

  # Reads and enables pagination through a set of `StationMount`.
  allStationMounts(
    # The method to use when ordering `StationMount`.
    orderBy: StationMountsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationMountCondition
  ): StationMountsConnection

  # Reads a single `StationMount` using its globally unique `ID`.
  stationMount(
    # The globally unique `ID` to be used in selecting a single `StationMount`.
    nodeId: ID!
  ): StationMount
  stationMountById(id: Int!): StationMount

  # Reads and enables pagination through a set of `StationPlaylist`.
  allStationPlaylists(
    # The method to use when ordering `StationPlaylist`.
    orderBy: StationPlaylistsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationPlaylistCondition
  ): StationPlaylistsConnection

  # Reads a single `StationPlaylist` using its globally unique `ID`.
  stationPlaylist(
    # The globally unique `ID` to be used in selecting a single `StationPlaylist`.
    nodeId: ID!
  ): StationPlaylist
  stationPlaylistById(id: Int!): StationPlaylist
  stationPlaylistByStationIdAndPlaylistId(stationId: Int!, playlistId: Int!): StationPlaylist

  # Reads and enables pagination through a set of `StationPodcast`.
  allStationPodcasts(
    # The method to use when ordering `StationPodcast`.
    orderBy: StationPodcastsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationPodcastCondition
  ): StationPodcastsConnection

  # Reads a single `StationPodcast` using its globally unique `ID`.
  stationPodcast(
    # The globally unique `ID` to be used in selecting a single `StationPodcast`.
    nodeId: ID!
  ): StationPodcast
  stationPodcastById(id: Int!): StationPodcast
  stationPodcastByStationIdAndPodcastId(stationId: Int!, podcastId: Int!): StationPodcast

  # Reads and enables pagination through a set of `StationShow`.
  allStationShows(
    # The method to use when ordering `StationShow`.
    orderBy: StationShowsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationShowCondition
  ): StationShowsConnection

  # Reads a single `StationShow` using its globally unique `ID`.
  stationShow(
    # The globally unique `ID` to be used in selecting a single `StationShow`.
    nodeId: ID!
  ): StationShow
  stationShowById(id: Int!): StationShow

  # Reads and enables pagination through a set of `StationShowSchedule`.
  allStationShowSchedules(
    # The method to use when ordering `StationShowSchedule`.
    orderBy: StationShowSchedulesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationShowScheduleCondition
  ): StationShowSchedulesConnection

  # Reads a single `StationShowSchedule` using its globally unique `ID`.
  stationShowSchedule(
    # The globally unique `ID` to be used in selecting a single `StationShowSchedule`.
    nodeId: ID!
  ): StationShowSchedule
  stationShowScheduleById(id: Int!): StationShowSchedule

  # Reads and enables pagination through a set of `StationStream`.
  allStationStreams(
    # The method to use when ordering `StationStream`.
    orderBy: StationStreamsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationStreamCondition
  ): StationStreamsConnection

  # Reads a single `StationStream` using its globally unique `ID`.
  stationStream(
    # The globally unique `ID` to be used in selecting a single `StationStream`.
    nodeId: ID!
  ): StationStream
  stationStreamById(id: Int!): StationStream

  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  nodeId: ID!
}

# A connection to a list of `Podcast` values.
type RecommendedPodcastsByMarketIdConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Podcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Podcast` and cursor to aid in pagination.
  edges: [RecommendedPodcastsByMarketIdEdge]

  # A list of `Podcast` objects.
  nodes: [Podcast]
}

# A `Podcast` edge in the connection.
type RecommendedPodcastsByMarketIdEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Podcast` at the end of the edge.
  node: Podcast
}

# Methods to use when ordering `Podcast`.
enum RecommendedPodcastsByMarketIdOrderBy {
  NATURAL
}

# A connection to a list of `Podcast` values.
type RecommendedPodcastsByMarketIdsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Podcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Podcast` and cursor to aid in pagination.
  edges: [RecommendedPodcastsByMarketIdsEdge]

  # A list of `Podcast` objects.
  nodes: [Podcast]
}

# A `Podcast` edge in the connection.
type RecommendedPodcastsByMarketIdsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Podcast` at the end of the edge.
  node: Podcast
}

# Methods to use when ordering `Podcast`.
enum RecommendedPodcastsByMarketIdsOrderBy {
  NATURAL
}

# A connection to a list of `Station` values.
type RecommendedStationsByMarketIdConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Station` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Station` and cursor to aid in pagination.
  edges: [RecommendedStationsByMarketIdEdge]

  # A list of `Station` objects.
  nodes: [Station]
}

# A `Station` edge in the connection.
type RecommendedStationsByMarketIdEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Station` at the end of the edge.
  node: Station
}

# Methods to use when ordering `Station`.
enum RecommendedStationsByMarketIdOrderBy {
  NATURAL
}

# A connection to a list of `Station` values.
type RecommendedStationsByMarketIdsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Station` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Station` and cursor to aid in pagination.
  edges: [RecommendedStationsByMarketIdsEdge]

  # A list of `Station` objects.
  nodes: [Station]
}

# A `Station` edge in the connection.
type RecommendedStationsByMarketIdsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Station` at the end of the edge.
  node: Station
}

# Methods to use when ordering `Station`.
enum RecommendedStationsByMarketIdsOrderBy {
  NATURAL
}

# A connection to a list of `Clip` values.
type SearchAudioClipsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Clip` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Clip` and cursor to aid in pagination.
  edges: [SearchAudioClipsEdge]

  # A list of `Clip` objects.
  nodes: [Clip]
}

# A `Clip` edge in the connection.
type SearchAudioClipsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Clip` at the end of the edge.
  node: Clip
}

# Methods to use when ordering `Clip`.
enum SearchAudioClipsOrderBy {
  NATURAL
}

# A connection to a list of `Clip` values.
type SearchPodcastEpisodesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Clip` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Clip` and cursor to aid in pagination.
  edges: [SearchPodcastEpisodesEdge]

  # A list of `Clip` objects.
  nodes: [Clip]
}

# A `Clip` edge in the connection.
type SearchPodcastEpisodesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Clip` at the end of the edge.
  node: Clip
}

# Methods to use when ordering `Clip`.
enum SearchPodcastEpisodesOrderBy {
  NATURAL
}

# A connection to a list of `Podcast` values.
type SearchPodcastsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Podcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Podcast` and cursor to aid in pagination.
  edges: [SearchPodcastsEdge]

  # A list of `Podcast` objects.
  nodes: [Podcast]
}

# A `Podcast` edge in the connection.
type SearchPodcastsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Podcast` at the end of the edge.
  node: Podcast
}

# Methods to use when ordering `Podcast`.
enum SearchPodcastsOrderBy {
  NATURAL
}

# A connection to a list of `Station` values.
type SearchStationsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Station` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Station` and cursor to aid in pagination.
  edges: [SearchStationsEdge]

  # A list of `Station` objects.
  nodes: [Station]
}

# A `Station` edge in the connection.
type SearchStationsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Station` at the end of the edge.
  node: Station
}

# Methods to use when ordering `Station`.
enum SearchStationsOrderBy {
  NATURAL
}

type Show implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String
  siteUrl: String
  heroImage: String
  image: String
  createdDate: Datetime!
  modifiedDate: Datetime!
  programId: String
  detail: Boolean

  # Reads and enables pagination through a set of `ShowModule`.
  showModulesByShowId(
    # The method to use when ordering `ShowModule`.
    orderBy: ShowModulesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ShowModuleCondition
  ): ShowModulesConnection

  # Reads and enables pagination through a set of `ShowPlaylist`.
  showPlaylistsByShowId(
    # The method to use when ordering `ShowPlaylist`.
    orderBy: ShowPlaylistsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ShowPlaylistCondition
  ): ShowPlaylistsConnection

  # Reads and enables pagination through a set of `ShowPodcast`.
  showPodcastsByShowId(
    # The method to use when ordering `ShowPodcast`.
    orderBy: ShowPodcastsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ShowPodcastCondition
  ): ShowPodcastsConnection

  # Reads and enables pagination through a set of `StationShow`.
  stationShowsByShowId(
    # The method to use when ordering `StationShow`.
    orderBy: StationShowsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationShowCondition
  ): StationShowsConnection
}

# A condition to be used against `Show` object types. All fields are tested for equality and combined with a logical ‘and.’
input ShowCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `siteUrl` field.
  siteUrl: String

  # Checks for equality with the object’s `heroImage` field.
  heroImage: String

  # Checks for equality with the object’s `image` field.
  image: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime

  # Checks for equality with the object’s `programId` field.
  programId: String

  # Checks for equality with the object’s `detail` field.
  detail: Boolean
}

input ShowInput {
  id: Int
  name: String
  siteUrl: String
  heroImage: String
  image: String
  createdDate: Datetime
  modifiedDate: Datetime
  programId: String
  detail: Boolean
}

type ShowModule implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  showId: Int!
  sortOrder: Int
  moduleType: ModuleType!
  objectId: Int
  displayName: String!
  viewMoreUrl: String
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Show` that is related to this `ShowModule`.
  showByShowId: Show

  # Reads and enables pagination through a set of `ShowModuleCustom`.
  showModuleCustomsByShowModuleId(
    # The method to use when ordering `ShowModuleCustom`.
    orderBy: ShowModuleCustomsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ShowModuleCustomCondition
  ): ShowModuleCustomsConnection
}

# A condition to be used against `ShowModule` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input ShowModuleCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `showId` field.
  showId: Int

  # Checks for equality with the object’s `sortOrder` field.
  sortOrder: Int

  # Checks for equality with the object’s `moduleType` field.
  moduleType: ModuleType

  # Checks for equality with the object’s `objectId` field.
  objectId: Int

  # Checks for equality with the object’s `displayName` field.
  displayName: String

  # Checks for equality with the object’s `viewMoreUrl` field.
  viewMoreUrl: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

type ShowModuleCustom implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  showModuleId: Int!
  sortOrder: Int
  image: String
  label: String
  subLabel: String
  webView: Boolean
  url: String
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `ShowModule` that is related to this `ShowModuleCustom`.
  showModuleByShowModuleId: ShowModule
}

# A condition to be used against `ShowModuleCustom` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input ShowModuleCustomCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `showModuleId` field.
  showModuleId: Int

  # Checks for equality with the object’s `sortOrder` field.
  sortOrder: Int

  # Checks for equality with the object’s `image` field.
  image: String

  # Checks for equality with the object’s `label` field.
  label: String

  # Checks for equality with the object’s `subLabel` field.
  subLabel: String

  # Checks for equality with the object’s `webView` field.
  webView: Boolean

  # Checks for equality with the object’s `url` field.
  url: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input ShowModuleCustomInput {
  id: Int
  showModuleId: Int!
  sortOrder: Int
  image: String
  label: String
  subLabel: String
  webView: Boolean
  url: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `ShowModuleCustom`. Fields that are set will be updated.
input ShowModuleCustomPatch {
  id: Int
  showModuleId: Int
  sortOrder: Int
  image: String
  label: String
  subLabel: String
  webView: Boolean
  url: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `ShowModuleCustom` values.
type ShowModuleCustomsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ShowModuleCustom` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `ShowModuleCustom` and cursor to aid in pagination.
  edges: [ShowModuleCustomsEdge]

  # A list of `ShowModuleCustom` objects.
  nodes: [ShowModuleCustom!]
}

# A `ShowModuleCustom` edge in the connection.
type ShowModuleCustomsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ShowModuleCustom` at the end of the edge.
  node: ShowModuleCustom!
}

# Methods to use when ordering `ShowModuleCustom`.
enum ShowModuleCustomsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  SHOW_MODULE_ID_ASC
  SHOW_MODULE_ID_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  IMAGE_ASC
  IMAGE_DESC
  LABEL_ASC
  LABEL_DESC
  SUB_LABEL_ASC
  SUB_LABEL_DESC
  WEB_VIEW_ASC
  WEB_VIEW_DESC
  URL_ASC
  URL_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

input ShowModuleInput {
  id: Int
  showId: Int!
  sortOrder: Int
  moduleType: ModuleType!
  objectId: Int
  displayName: String!
  viewMoreUrl: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `ShowModule`. Fields that are set will be updated.
input ShowModulePatch {
  id: Int
  showId: Int
  sortOrder: Int
  moduleType: ModuleType
  objectId: Int
  displayName: String
  viewMoreUrl: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `ShowModule` values.
type ShowModulesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ShowModule` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `ShowModule` and cursor to aid in pagination.
  edges: [ShowModulesEdge]

  # A list of `ShowModule` objects.
  nodes: [ShowModule!]
}

# A `ShowModule` edge in the connection.
type ShowModulesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ShowModule` at the end of the edge.
  node: ShowModule!
}

# Methods to use when ordering `ShowModule`.
enum ShowModulesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  SHOW_ID_ASC
  SHOW_ID_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  MODULE_TYPE_ASC
  MODULE_TYPE_DESC
  OBJECT_ID_ASC
  OBJECT_ID_DESC
  DISPLAY_NAME_ASC
  DISPLAY_NAME_DESC
  VIEW_MORE_URL_ASC
  VIEW_MORE_URL_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

# Represents an update to a `Show`. Fields that are set will be updated.
input ShowPatch {
  id: Int
  name: String
  siteUrl: String
  heroImage: String
  image: String
  createdDate: Datetime
  modifiedDate: Datetime
  programId: String
  detail: Boolean
}

type ShowPlaylist implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  showId: Int!
  playlistId: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Show` that is related to this `ShowPlaylist`.
  showByShowId: Show

  # Reads a single `Playlist` that is related to this `ShowPlaylist`.
  playlistByPlaylistId: Playlist
}

# A condition to be used against `ShowPlaylist` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input ShowPlaylistCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `showId` field.
  showId: Int

  # Checks for equality with the object’s `playlistId` field.
  playlistId: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input ShowPlaylistInput {
  id: Int
  showId: Int!
  playlistId: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `ShowPlaylist`. Fields that are set will be updated.
input ShowPlaylistPatch {
  id: Int
  showId: Int
  playlistId: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `ShowPlaylist` values.
type ShowPlaylistsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ShowPlaylist` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `ShowPlaylist` and cursor to aid in pagination.
  edges: [ShowPlaylistsEdge]

  # A list of `ShowPlaylist` objects.
  nodes: [ShowPlaylist!]
}

# A `ShowPlaylist` edge in the connection.
type ShowPlaylistsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ShowPlaylist` at the end of the edge.
  node: ShowPlaylist!
}

# Methods to use when ordering `ShowPlaylist`.
enum ShowPlaylistsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  SHOW_ID_ASC
  SHOW_ID_DESC
  PLAYLIST_ID_ASC
  PLAYLIST_ID_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

type ShowPodcast implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  showId: Int!
  podcastId: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Show` that is related to this `ShowPodcast`.
  showByShowId: Show

  # Reads a single `Podcast` that is related to this `ShowPodcast`.
  podcastByPodcastId: Podcast
}

# A condition to be used against `ShowPodcast` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input ShowPodcastCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `showId` field.
  showId: Int

  # Checks for equality with the object’s `podcastId` field.
  podcastId: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input ShowPodcastInput {
  id: Int
  showId: Int!
  podcastId: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `ShowPodcast`. Fields that are set will be updated.
input ShowPodcastPatch {
  id: Int
  showId: Int
  podcastId: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `ShowPodcast` values.
type ShowPodcastsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ShowPodcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `ShowPodcast` and cursor to aid in pagination.
  edges: [ShowPodcastsEdge]

  # A list of `ShowPodcast` objects.
  nodes: [ShowPodcast!]
}

# A `ShowPodcast` edge in the connection.
type ShowPodcastsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ShowPodcast` at the end of the edge.
  node: ShowPodcast!
}

# Methods to use when ordering `ShowPodcast`.
enum ShowPodcastsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  SHOW_ID_ASC
  SHOW_ID_DESC
  PODCAST_ID_ASC
  PODCAST_ID_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

# A connection to a list of `Show` values.
type ShowsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Show` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Show` and cursor to aid in pagination.
  edges: [ShowsEdge]

  # A list of `Show` objects.
  nodes: [Show!]
}

# A `Show` edge in the connection.
type ShowsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Show` at the end of the edge.
  node: Show!
}

# Methods to use when ordering `Show`.
enum ShowsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  SITE_URL_ASC
  SITE_URL_DESC
  HERO_IMAGE_ASC
  HERO_IMAGE_DESC
  IMAGE_ASC
  IMAGE_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
  PROGRAM_ID_ASC
  PROGRAM_ID_DESC
  DETAIL_ASC
  DETAIL_DESC
}

type Song implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  ufid: String!
  title: String!
  artist: String!
  album: String
  imageUrl: String
  imageUrlHiRes: String
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads and enables pagination through a set of `SongPlay`.
  songPlaysBySongId(
    # The method to use when ordering `SongPlay`.
    orderBy: SongPlaysOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SongPlayCondition
  ): SongPlaysConnection
}

# A condition to be used against `Song` object types. All fields are tested for equality and combined with a logical ‘and.’
input SongCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `ufid` field.
  ufid: String

  # Checks for equality with the object’s `title` field.
  title: String

  # Checks for equality with the object’s `artist` field.
  artist: String

  # Checks for equality with the object’s `album` field.
  album: String

  # Checks for equality with the object’s `imageUrl` field.
  imageUrl: String

  # Checks for equality with the object’s `imageUrlHiRes` field.
  imageUrlHiRes: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input SongInput {
  id: Int
  ufid: String!
  title: String!
  artist: String!
  album: String
  imageUrl: String
  imageUrlHiRes: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `Song`. Fields that are set will be updated.
input SongPatch {
  id: Int
  ufid: String
  title: String
  artist: String
  album: String
  imageUrl: String
  imageUrlHiRes: String
  createdDate: Datetime
  modifiedDate: Datetime
}

type SongPlay implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  songId: Int!
  stationId: Int!
  playedDate: Datetime!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Song` that is related to this `SongPlay`.
  songBySongId: Song

  # Reads a single `Station` that is related to this `SongPlay`.
  stationByStationId: Station
}

# A condition to be used against `SongPlay` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input SongPlayCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `songId` field.
  songId: Int

  # Checks for equality with the object’s `stationId` field.
  stationId: Int

  # Checks for equality with the object’s `playedDate` field.
  playedDate: Datetime

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input SongPlayInput {
  id: Int
  songId: Int!
  stationId: Int!
  playedDate: Datetime!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `SongPlay`. Fields that are set will be updated.
input SongPlayPatch {
  id: Int
  songId: Int
  stationId: Int
  playedDate: Datetime
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `SongPlay` values.
type SongPlaysConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `SongPlay` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `SongPlay` and cursor to aid in pagination.
  edges: [SongPlaysEdge]

  # A list of `SongPlay` objects.
  nodes: [SongPlay!]
}

# A `SongPlay` edge in the connection.
type SongPlaysEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `SongPlay` at the end of the edge.
  node: SongPlay!
}

# Methods to use when ordering `SongPlay`.
enum SongPlaysOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  SONG_ID_ASC
  SONG_ID_DESC
  STATION_ID_ASC
  STATION_ID_DESC
  PLAYED_DATE_ASC
  PLAYED_DATE_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

# A connection to a list of `Song` values.
type SongsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Song` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Song` and cursor to aid in pagination.
  edges: [SongsEdge]

  # A list of `Song` objects.
  nodes: [Song!]
}

# A `Song` edge in the connection.
type SongsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Song` at the end of the edge.
  node: Song!
}

# Methods to use when ordering `Song`.
enum SongsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  UFID_ASC
  UFID_DESC
  TITLE_ASC
  TITLE_DESC
  ARTIST_ASC
  ARTIST_DESC
  ALBUM_ASC
  ALBUM_DESC
  IMAGE_URL_ASC
  IMAGE_URL_DESC
  IMAGE_URL_HI_RES_ASC
  IMAGE_URL_HI_RES_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

# A connection to a list of `Clip` values.
type SortedPodcastClipsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Clip` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Clip` and cursor to aid in pagination.
  edges: [SortedPodcastClipsEdge]

  # A list of `Clip` objects.
  nodes: [Clip]
}

# A `Clip` edge in the connection.
type SortedPodcastClipsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Clip` at the end of the edge.
  node: Clip
}

# Methods to use when ordering `Clip`.
enum SortedPodcastClipsOrderBy {
  NATURAL
}

type Station implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  r20id: Int
  name: String!
  slogan: String
  description: String
  format: String
  website: String
  callsign: String
  slug: String
  category: StationCategoryType!
  bband: StationBbandType
  frequency: String
  listenLiveUrl: String
  streamType: String!
  gaid: String
  partner: String!
  status: Int!
  heroImage: String
  squareLogoSmall: String
  squareLogoLarge: String
  logoSvg: String
  tritonId: Int
  tritonName: String
  city: String
  state: String
  country: String
  postalCode: String
  gmtOffset: Int
  observesDst: Boolean
  latitude: Float
  longitude: Float
  marketId: Int
  andoId: Int
  doubleclickPrerolltag: String
  doubleclickBannertag: String
  targetspotId: String
  facebook: String
  twitter: String
  tuneInUrl: String
  createdDate: Datetime!
  modifiedDate: Datetime!
  popularity: Int!
  primaryColor: String
  secondaryColor: String
  tagStationId: Int
  nielsenAssetId: String
  nielsenStationType: String
  keywords: String

  # Reads and enables pagination through a set of `Podcast`.
  allStationPodcasts(
    # The method to use when ordering `Podcast`.
    orderBy: StationAllStationPodcastsOrderBy = NATURAL

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int
  ): StationAllStationPodcastsConnection

  # Reads a single `Market` that is related to this `Station`.
  marketByMarketId: Market

  # Reads and enables pagination through a set of `FeaturedStation`.
  featuredStationsByStationId(
    # The method to use when ordering `FeaturedStation`.
    orderBy: FeaturedStationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FeaturedStationCondition
  ): FeaturedStationsConnection

  # Reads and enables pagination through a set of `SongPlay`.
  songPlaysByStationId(
    # The method to use when ordering `SongPlay`.
    orderBy: SongPlaysOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SongPlayCondition
  ): SongPlaysConnection

  # Reads and enables pagination through a set of `StationGenre`.
  stationGenresByStationId(
    # The method to use when ordering `StationGenre`.
    orderBy: StationGenresOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationGenreCondition
  ): StationGenresConnection

  # Reads and enables pagination through a set of `StationModule`.
  stationModulesByStationId(
    # The method to use when ordering `StationModule`.
    orderBy: StationModulesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationModuleCondition
  ): StationModulesConnection

  # Reads and enables pagination through a set of `StationMount`.
  stationMountsByStationId(
    # The method to use when ordering `StationMount`.
    orderBy: StationMountsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationMountCondition
  ): StationMountsConnection

  # Reads and enables pagination through a set of `StationPlaylist`.
  stationPlaylistsByStationId(
    # The method to use when ordering `StationPlaylist`.
    orderBy: StationPlaylistsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationPlaylistCondition
  ): StationPlaylistsConnection

  # Reads and enables pagination through a set of `StationPodcast`.
  stationPodcastsByStationId(
    # The method to use when ordering `StationPodcast`.
    orderBy: StationPodcastsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationPodcastCondition
  ): StationPodcastsConnection

  # Reads and enables pagination through a set of `StationShow`.
  stationShowsByStationId(
    # The method to use when ordering `StationShow`.
    orderBy: StationShowsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationShowCondition
  ): StationShowsConnection

  # Reads and enables pagination through a set of `StationStream`.
  stationStreamsByStationId(
    # The method to use when ordering `StationStream`.
    orderBy: StationStreamsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationStreamCondition
  ): StationStreamsConnection
}

# A connection to a list of `Podcast` values.
type StationAllStationPodcastsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Podcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Podcast` and cursor to aid in pagination.
  edges: [StationAllStationPodcastsEdge]

  # A list of `Podcast` objects.
  nodes: [Podcast]
}

# A `Podcast` edge in the connection.
type StationAllStationPodcastsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Podcast` at the end of the edge.
  node: Podcast
}

# Methods to use when ordering `Podcast`.
enum StationAllStationPodcastsOrderBy {
  NATURAL
}

enum StationBbandType {
  FM
  AM
  HD
}

enum StationCategoryType {
  MUSIC
  NEWS
  TALK
  SPORTS
}

# A condition to be used against `Station` object types. All fields are tested for equality and combined with a logical ‘and.’
input StationCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `r20id` field.
  r20id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `slogan` field.
  slogan: String

  # Checks for equality with the object’s `description` field.
  description: String

  # Checks for equality with the object’s `format` field.
  format: String

  # Checks for equality with the object’s `website` field.
  website: String

  # Checks for equality with the object’s `callsign` field.
  callsign: String

  # Checks for equality with the object’s `slug` field.
  slug: String

  # Checks for equality with the object’s `category` field.
  category: StationCategoryType

  # Checks for equality with the object’s `bband` field.
  bband: StationBbandType

  # Checks for equality with the object’s `frequency` field.
  frequency: String

  # Checks for equality with the object’s `listenLiveUrl` field.
  listenLiveUrl: String

  # Checks for equality with the object’s `streamType` field.
  streamType: String

  # Checks for equality with the object’s `gaid` field.
  gaid: String

  # Checks for equality with the object’s `partner` field.
  partner: String

  # Checks for equality with the object’s `status` field.
  status: Int

  # Checks for equality with the object’s `heroImage` field.
  heroImage: String

  # Checks for equality with the object’s `squareLogoSmall` field.
  squareLogoSmall: String

  # Checks for equality with the object’s `squareLogoLarge` field.
  squareLogoLarge: String

  # Checks for equality with the object’s `logoSvg` field.
  logoSvg: String

  # Checks for equality with the object’s `tritonId` field.
  tritonId: Int

  # Checks for equality with the object’s `tritonName` field.
  tritonName: String

  # Checks for equality with the object’s `city` field.
  city: String

  # Checks for equality with the object’s `state` field.
  state: String

  # Checks for equality with the object’s `country` field.
  country: String

  # Checks for equality with the object’s `postalCode` field.
  postalCode: String

  # Checks for equality with the object’s `gmtOffset` field.
  gmtOffset: Int

  # Checks for equality with the object’s `observesDst` field.
  observesDst: Boolean

  # Checks for equality with the object’s `latitude` field.
  latitude: Float

  # Checks for equality with the object’s `longitude` field.
  longitude: Float

  # Checks for equality with the object’s `marketId` field.
  marketId: Int

  # Checks for equality with the object’s `andoId` field.
  andoId: Int

  # Checks for equality with the object’s `doubleclickPrerolltag` field.
  doubleclickPrerolltag: String

  # Checks for equality with the object’s `doubleclickBannertag` field.
  doubleclickBannertag: String

  # Checks for equality with the object’s `targetspotId` field.
  targetspotId: String

  # Checks for equality with the object’s `facebook` field.
  facebook: String

  # Checks for equality with the object’s `twitter` field.
  twitter: String

  # Checks for equality with the object’s `tuneInUrl` field.
  tuneInUrl: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime

  # Checks for equality with the object’s `popularity` field.
  popularity: Int

  # Checks for equality with the object’s `primaryColor` field.
  primaryColor: String

  # Checks for equality with the object’s `secondaryColor` field.
  secondaryColor: String

  # Checks for equality with the object’s `tagStationId` field.
  tagStationId: Int

  # Checks for equality with the object’s `nielsenAssetId` field.
  nielsenAssetId: String

  # Checks for equality with the object’s `nielsenStationType` field.
  nielsenStationType: String

  # Checks for equality with the object’s `keywords` field.
  keywords: String
}

type StationGenre implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  stationId: Int!
  genreId: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Station` that is related to this `StationGenre`.
  stationByStationId: Station

  # Reads a single `Genre` that is related to this `StationGenre`.
  genreByGenreId: Genre
}

# A condition to be used against `StationGenre` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input StationGenreCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `stationId` field.
  stationId: Int

  # Checks for equality with the object’s `genreId` field.
  genreId: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input StationGenreInput {
  id: Int
  stationId: Int!
  genreId: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `StationGenre`. Fields that are set will be updated.
input StationGenrePatch {
  id: Int
  stationId: Int
  genreId: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `StationGenre` values.
type StationGenresConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StationGenre` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StationGenre` and cursor to aid in pagination.
  edges: [StationGenresEdge]

  # A list of `StationGenre` objects.
  nodes: [StationGenre!]
}

# A `StationGenre` edge in the connection.
type StationGenresEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StationGenre` at the end of the edge.
  node: StationGenre!
}

# Methods to use when ordering `StationGenre`.
enum StationGenresOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STATION_ID_ASC
  STATION_ID_DESC
  GENRE_ID_ASC
  GENRE_ID_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

input StationInput {
  id: Int
  r20id: Int
  name: String!
  slogan: String
  description: String
  format: String
  website: String
  callsign: String
  slug: String
  category: StationCategoryType!
  bband: StationBbandType
  frequency: String
  listenLiveUrl: String
  streamType: String!
  gaid: String
  partner: String!
  status: Int!
  heroImage: String
  squareLogoSmall: String
  squareLogoLarge: String
  logoSvg: String
  tritonId: Int
  tritonName: String
  city: String
  state: String
  country: String
  postalCode: String
  gmtOffset: Int
  observesDst: Boolean
  latitude: Float
  longitude: Float
  marketId: Int
  andoId: Int
  doubleclickPrerolltag: String
  doubleclickBannertag: String
  targetspotId: String
  facebook: String
  twitter: String
  tuneInUrl: String
  createdDate: Datetime
  modifiedDate: Datetime
  popularity: Int
  primaryColor: String
  secondaryColor: String
  tagStationId: Int
  nielsenAssetId: String
  nielsenStationType: String
  keywords: String
}

type StationModule implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  stationId: Int!
  sortOrder: Int
  moduleType: ModuleType!
  objectId: Int
  displayName: String!
  viewMoreUrl: String
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Station` that is related to this `StationModule`.
  stationByStationId: Station

  # Reads and enables pagination through a set of `StationModuleCustom`.
  stationModuleCustomsByStationModuleId(
    # The method to use when ordering `StationModuleCustom`.
    orderBy: StationModuleCustomsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationModuleCustomCondition
  ): StationModuleCustomsConnection
}

# A condition to be used against `StationModule` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input StationModuleCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `stationId` field.
  stationId: Int

  # Checks for equality with the object’s `sortOrder` field.
  sortOrder: Int

  # Checks for equality with the object’s `moduleType` field.
  moduleType: ModuleType

  # Checks for equality with the object’s `objectId` field.
  objectId: Int

  # Checks for equality with the object’s `displayName` field.
  displayName: String

  # Checks for equality with the object’s `viewMoreUrl` field.
  viewMoreUrl: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

type StationModuleCustom implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  stationModuleId: Int!
  sortOrder: Int
  image: String
  label: String
  subLabel: String
  webView: Boolean
  url: String
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `StationModule` that is related to this `StationModuleCustom`.
  stationModuleByStationModuleId: StationModule
}

# A condition to be used against `StationModuleCustom` object types. All fields
# are tested for equality and combined with a logical ‘and.’
input StationModuleCustomCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `stationModuleId` field.
  stationModuleId: Int

  # Checks for equality with the object’s `sortOrder` field.
  sortOrder: Int

  # Checks for equality with the object’s `image` field.
  image: String

  # Checks for equality with the object’s `label` field.
  label: String

  # Checks for equality with the object’s `subLabel` field.
  subLabel: String

  # Checks for equality with the object’s `webView` field.
  webView: Boolean

  # Checks for equality with the object’s `url` field.
  url: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input StationModuleCustomInput {
  id: Int
  stationModuleId: Int!
  sortOrder: Int
  image: String
  label: String
  subLabel: String
  webView: Boolean
  url: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `StationModuleCustom`. Fields that are set will be updated.
input StationModuleCustomPatch {
  id: Int
  stationModuleId: Int
  sortOrder: Int
  image: String
  label: String
  subLabel: String
  webView: Boolean
  url: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `StationModuleCustom` values.
type StationModuleCustomsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StationModuleCustom` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StationModuleCustom` and cursor to aid in pagination.
  edges: [StationModuleCustomsEdge]

  # A list of `StationModuleCustom` objects.
  nodes: [StationModuleCustom!]
}

# A `StationModuleCustom` edge in the connection.
type StationModuleCustomsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StationModuleCustom` at the end of the edge.
  node: StationModuleCustom!
}

# Methods to use when ordering `StationModuleCustom`.
enum StationModuleCustomsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STATION_MODULE_ID_ASC
  STATION_MODULE_ID_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  IMAGE_ASC
  IMAGE_DESC
  LABEL_ASC
  LABEL_DESC
  SUB_LABEL_ASC
  SUB_LABEL_DESC
  WEB_VIEW_ASC
  WEB_VIEW_DESC
  URL_ASC
  URL_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

input StationModuleInput {
  id: Int
  stationId: Int!
  sortOrder: Int
  moduleType: ModuleType!
  objectId: Int
  displayName: String!
  viewMoreUrl: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `StationModule`. Fields that are set will be updated.
input StationModulePatch {
  id: Int
  stationId: Int
  sortOrder: Int
  moduleType: ModuleType
  objectId: Int
  displayName: String
  viewMoreUrl: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `StationModule` values.
type StationModulesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StationModule` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StationModule` and cursor to aid in pagination.
  edges: [StationModulesEdge]

  # A list of `StationModule` objects.
  nodes: [StationModule!]
}

# A `StationModule` edge in the connection.
type StationModulesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StationModule` at the end of the edge.
  node: StationModule!
}

# Methods to use when ordering `StationModule`.
enum StationModulesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STATION_ID_ASC
  STATION_ID_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  MODULE_TYPE_ASC
  MODULE_TYPE_DESC
  OBJECT_ID_ASC
  OBJECT_ID_DESC
  DISPLAY_NAME_ASC
  DISPLAY_NAME_DESC
  VIEW_MORE_URL_ASC
  VIEW_MORE_URL_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

type StationMount implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  stationId: Int!
  type: MountType!
  mount: String!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Station` that is related to this `StationMount`.
  stationByStationId: Station
}

# A condition to be used against `StationMount` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input StationMountCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `stationId` field.
  stationId: Int

  # Checks for equality with the object’s `type` field.
  type: MountType

  # Checks for equality with the object’s `mount` field.
  mount: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input StationMountInput {
  id: Int
  stationId: Int!
  type: MountType!
  mount: String!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `StationMount`. Fields that are set will be updated.
input StationMountPatch {
  id: Int
  stationId: Int
  type: MountType
  mount: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `StationMount` values.
type StationMountsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StationMount` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StationMount` and cursor to aid in pagination.
  edges: [StationMountsEdge]

  # A list of `StationMount` objects.
  nodes: [StationMount!]
}

# A `StationMount` edge in the connection.
type StationMountsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StationMount` at the end of the edge.
  node: StationMount!
}

# Methods to use when ordering `StationMount`.
enum StationMountsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STATION_ID_ASC
  STATION_ID_DESC
  TYPE_ASC
  TYPE_DESC
  MOUNT_ASC
  MOUNT_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

# Represents an update to a `Station`. Fields that are set will be updated.
input StationPatch {
  id: Int
  r20id: Int
  name: String
  slogan: String
  description: String
  format: String
  website: String
  callsign: String
  slug: String
  category: StationCategoryType
  bband: StationBbandType
  frequency: String
  listenLiveUrl: String
  streamType: String
  gaid: String
  partner: String
  status: Int
  heroImage: String
  squareLogoSmall: String
  squareLogoLarge: String
  logoSvg: String
  tritonId: Int
  tritonName: String
  city: String
  state: String
  country: String
  postalCode: String
  gmtOffset: Int
  observesDst: Boolean
  latitude: Float
  longitude: Float
  marketId: Int
  andoId: Int
  doubleclickPrerolltag: String
  doubleclickBannertag: String
  targetspotId: String
  facebook: String
  twitter: String
  tuneInUrl: String
  createdDate: Datetime
  modifiedDate: Datetime
  popularity: Int
  primaryColor: String
  secondaryColor: String
  tagStationId: Int
  nielsenAssetId: String
  nielsenStationType: String
  keywords: String
}

type StationPlaylist implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  stationId: Int!
  playlistId: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Station` that is related to this `StationPlaylist`.
  stationByStationId: Station

  # Reads a single `Playlist` that is related to this `StationPlaylist`.
  playlistByPlaylistId: Playlist
}

# A condition to be used against `StationPlaylist` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input StationPlaylistCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `stationId` field.
  stationId: Int

  # Checks for equality with the object’s `playlistId` field.
  playlistId: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input StationPlaylistInput {
  id: Int
  stationId: Int!
  playlistId: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `StationPlaylist`. Fields that are set will be updated.
input StationPlaylistPatch {
  id: Int
  stationId: Int
  playlistId: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `StationPlaylist` values.
type StationPlaylistsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StationPlaylist` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StationPlaylist` and cursor to aid in pagination.
  edges: [StationPlaylistsEdge]

  # A list of `StationPlaylist` objects.
  nodes: [StationPlaylist!]
}

# A `StationPlaylist` edge in the connection.
type StationPlaylistsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StationPlaylist` at the end of the edge.
  node: StationPlaylist!
}

# Methods to use when ordering `StationPlaylist`.
enum StationPlaylistsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STATION_ID_ASC
  STATION_ID_DESC
  PLAYLIST_ID_ASC
  PLAYLIST_ID_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

type StationPodcast implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  stationId: Int!
  podcastId: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Station` that is related to this `StationPodcast`.
  stationByStationId: Station

  # Reads a single `Podcast` that is related to this `StationPodcast`.
  podcastByPodcastId: Podcast
}

# A condition to be used against `StationPodcast` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input StationPodcastCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `stationId` field.
  stationId: Int

  # Checks for equality with the object’s `podcastId` field.
  podcastId: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input StationPodcastInput {
  id: Int
  stationId: Int!
  podcastId: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `StationPodcast`. Fields that are set will be updated.
input StationPodcastPatch {
  id: Int
  stationId: Int
  podcastId: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `StationPodcast` values.
type StationPodcastsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StationPodcast` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StationPodcast` and cursor to aid in pagination.
  edges: [StationPodcastsEdge]

  # A list of `StationPodcast` objects.
  nodes: [StationPodcast!]
}

# A `StationPodcast` edge in the connection.
type StationPodcastsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StationPodcast` at the end of the edge.
  node: StationPodcast!
}

# Methods to use when ordering `StationPodcast`.
enum StationPodcastsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STATION_ID_ASC
  STATION_ID_DESC
  PODCAST_ID_ASC
  PODCAST_ID_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

# A connection to a list of `Station` values.
type StationsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Station` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Station` and cursor to aid in pagination.
  edges: [StationsEdge]

  # A list of `Station` objects.
  nodes: [Station!]
}

# A `Station` edge in the connection.
type StationsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Station` at the end of the edge.
  node: Station!
}

type StationShow implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  stationId: Int!
  showId: Int!
  displaySchedule: String
  createdDate: Datetime!
  modifiedDate: Datetime!
  sortOrder: Int

  # Reads a single `Station` that is related to this `StationShow`.
  stationByStationId: Station

  # Reads a single `Show` that is related to this `StationShow`.
  showByShowId: Show

  # Reads and enables pagination through a set of `StationShowSchedule`.
  stationShowSchedulesByStationShowId(
    # The method to use when ordering `StationShowSchedule`.
    orderBy: StationShowSchedulesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StationShowScheduleCondition
  ): StationShowSchedulesConnection
}

# A condition to be used against `StationShow` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input StationShowCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `stationId` field.
  stationId: Int

  # Checks for equality with the object’s `showId` field.
  showId: Int

  # Checks for equality with the object’s `displaySchedule` field.
  displaySchedule: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime

  # Checks for equality with the object’s `sortOrder` field.
  sortOrder: Int
}

input StationShowInput {
  id: Int
  stationId: Int!
  showId: Int!
  displaySchedule: String
  createdDate: Datetime
  modifiedDate: Datetime
  sortOrder: Int
}

# Represents an update to a `StationShow`. Fields that are set will be updated.
input StationShowPatch {
  id: Int
  stationId: Int
  showId: Int
  displaySchedule: String
  createdDate: Datetime
  modifiedDate: Datetime
  sortOrder: Int
}

type StationShowSchedule implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  stationShowId: Int!
  startTime: Time!
  endTime: Time!
  dayOfWeek: Int!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `StationShow` that is related to this `StationShowSchedule`.
  stationShowByStationShowId: StationShow
}

# A condition to be used against `StationShowSchedule` object types. All fields
# are tested for equality and combined with a logical ‘and.’
input StationShowScheduleCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `stationShowId` field.
  stationShowId: Int

  # Checks for equality with the object’s `startTime` field.
  startTime: Time

  # Checks for equality with the object’s `endTime` field.
  endTime: Time

  # Checks for equality with the object’s `dayOfWeek` field.
  dayOfWeek: Int

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input StationShowScheduleInput {
  id: Int
  stationShowId: Int!
  startTime: Time!
  endTime: Time!
  dayOfWeek: Int!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `StationShowSchedule`. Fields that are set will be updated.
input StationShowSchedulePatch {
  id: Int
  stationShowId: Int
  startTime: Time
  endTime: Time
  dayOfWeek: Int
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `StationShowSchedule` values.
type StationShowSchedulesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StationShowSchedule` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StationShowSchedule` and cursor to aid in pagination.
  edges: [StationShowSchedulesEdge]

  # A list of `StationShowSchedule` objects.
  nodes: [StationShowSchedule!]
}

# A `StationShowSchedule` edge in the connection.
type StationShowSchedulesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StationShowSchedule` at the end of the edge.
  node: StationShowSchedule!
}

# Methods to use when ordering `StationShowSchedule`.
enum StationShowSchedulesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STATION_SHOW_ID_ASC
  STATION_SHOW_ID_DESC
  START_TIME_ASC
  START_TIME_DESC
  END_TIME_ASC
  END_TIME_DESC
  DAY_OF_WEEK_ASC
  DAY_OF_WEEK_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

# A connection to a list of `StationShow` values.
type StationShowsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StationShow` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StationShow` and cursor to aid in pagination.
  edges: [StationShowsEdge]

  # A list of `StationShow` objects.
  nodes: [StationShow!]
}

# A `StationShow` edge in the connection.
type StationShowsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StationShow` at the end of the edge.
  node: StationShow!
}

# Methods to use when ordering `StationShow`.
enum StationShowsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STATION_ID_ASC
  STATION_ID_DESC
  SHOW_ID_ASC
  SHOW_ID_DESC
  DISPLAY_SCHEDULE_ASC
  DISPLAY_SCHEDULE_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
}

# Methods to use when ordering `Station`.
enum StationsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  R20ID_ASC
  R20ID_DESC
  NAME_ASC
  NAME_DESC
  SLOGAN_ASC
  SLOGAN_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  FORMAT_ASC
  FORMAT_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  CALLSIGN_ASC
  CALLSIGN_DESC
  SLUG_ASC
  SLUG_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  BBAND_ASC
  BBAND_DESC
  FREQUENCY_ASC
  FREQUENCY_DESC
  LISTEN_LIVE_URL_ASC
  LISTEN_LIVE_URL_DESC
  STREAM_TYPE_ASC
  STREAM_TYPE_DESC
  GAID_ASC
  GAID_DESC
  PARTNER_ASC
  PARTNER_DESC
  STATUS_ASC
  STATUS_DESC
  HERO_IMAGE_ASC
  HERO_IMAGE_DESC
  SQUARE_LOGO_SMALL_ASC
  SQUARE_LOGO_SMALL_DESC
  SQUARE_LOGO_LARGE_ASC
  SQUARE_LOGO_LARGE_DESC
  LOGO_SVG_ASC
  LOGO_SVG_DESC
  TRITON_ID_ASC
  TRITON_ID_DESC
  TRITON_NAME_ASC
  TRITON_NAME_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  POSTAL_CODE_ASC
  POSTAL_CODE_DESC
  GMT_OFFSET_ASC
  GMT_OFFSET_DESC
  OBSERVES_DST_ASC
  OBSERVES_DST_DESC
  LATITUDE_ASC
  LATITUDE_DESC
  LONGITUDE_ASC
  LONGITUDE_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  ANDO_ID_ASC
  ANDO_ID_DESC
  DOUBLECLICK_PREROLLTAG_ASC
  DOUBLECLICK_PREROLLTAG_DESC
  DOUBLECLICK_BANNERTAG_ASC
  DOUBLECLICK_BANNERTAG_DESC
  TARGETSPOT_ID_ASC
  TARGETSPOT_ID_DESC
  FACEBOOK_ASC
  FACEBOOK_DESC
  TWITTER_ASC
  TWITTER_DESC
  TUNE_IN_URL_ASC
  TUNE_IN_URL_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
  POPULARITY_ASC
  POPULARITY_DESC
  PRIMARY_COLOR_ASC
  PRIMARY_COLOR_DESC
  SECONDARY_COLOR_ASC
  SECONDARY_COLOR_DESC
  TAG_STATION_ID_ASC
  TAG_STATION_ID_DESC
  NIELSEN_ASSET_ID_ASC
  NIELSEN_ASSET_ID_DESC
  NIELSEN_STATION_TYPE_ASC
  NIELSEN_STATION_TYPE_DESC
  KEYWORDS_ASC
  KEYWORDS_DESC
}

type StationStream implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  stationId: Int!
  type: StreamType!
  url: String!
  createdDate: Datetime!
  modifiedDate: Datetime!

  # Reads a single `Station` that is related to this `StationStream`.
  stationByStationId: Station
}

# A condition to be used against `StationStream` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input StationStreamCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `stationId` field.
  stationId: Int

  # Checks for equality with the object’s `type` field.
  type: StreamType

  # Checks for equality with the object’s `url` field.
  url: String

  # Checks for equality with the object’s `createdDate` field.
  createdDate: Datetime

  # Checks for equality with the object’s `modifiedDate` field.
  modifiedDate: Datetime
}

input StationStreamInput {
  id: Int
  stationId: Int!
  type: StreamType!
  url: String!
  createdDate: Datetime
  modifiedDate: Datetime
}

# Represents an update to a `StationStream`. Fields that are set will be updated.
input StationStreamPatch {
  id: Int
  stationId: Int
  type: StreamType
  url: String
  createdDate: Datetime
  modifiedDate: Datetime
}

# A connection to a list of `StationStream` values.
type StationStreamsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StationStream` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StationStream` and cursor to aid in pagination.
  edges: [StationStreamsEdge]

  # A list of `StationStream` objects.
  nodes: [StationStream!]
}

# A `StationStream` edge in the connection.
type StationStreamsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StationStream` at the end of the edge.
  node: StationStream!
}

# Methods to use when ordering `StationStream`.
enum StationStreamsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STATION_ID_ASC
  STATION_ID_DESC
  TYPE_ASC
  TYPE_DESC
  URL_ASC
  URL_DESC
  CREATED_DATE_ASC
  CREATED_DATE_DESC
  MODIFIED_DATE_ASC
  MODIFIED_DATE_DESC
}

enum StreamType {
  MP3_PLS
  MP3_SHOUTCAST
  AAC_PLS
  AAC_SHOUTCAST
  HLS
}

# The exact time of day, does not include the date. May or may not have a timezone offset.
scalar Time

# All input for the `updateAdminUserByUserId` mutation.
input UpdateAdminUserByUserIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  userId: Int!

  # An object where the defined keys will be set on the `AdminUser` identified by our unique key.
  adminUserPatch: AdminUserPatch!
}

# All input for the `updateAdminUser` mutation.
input UpdateAdminUserInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `AdminUser` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `AdminUser` identified by our globally unique `ID`.
  adminUserPatch: AdminUserPatch!
}

# The output of our `updateAdminUser` mutation.
type UpdateAdminUserPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  adminUser: AdminUser

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateAdminUserPermByUserIdAndPageNameAndPermName` mutation.
input UpdateAdminUserPermByUserIdAndPageNameAndPermNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  userId: Int!
  pageName: String!
  permName: String!

  # An object where the defined keys will be set on the `AdminUserPerm` identified by our unique key.
  adminUserPermPatch: AdminUserPermPatch!
}

# All input for the `updateAdminUserPerm` mutation.
input UpdateAdminUserPermInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `AdminUserPerm` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `AdminUserPerm` identified by our globally unique `ID`.
  adminUserPermPatch: AdminUserPermPatch!
}

# The output of our `updateAdminUserPerm` mutation.
type UpdateAdminUserPermPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  adminUserPerm: AdminUserPerm

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateCategoryById` mutation.
input UpdateCategoryByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `Category` identified by our unique key.
  categoryPatch: CategoryPatch!
}

# All input for the `updateCategoryByName` mutation.
input UpdateCategoryByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!

  # An object where the defined keys will be set on the `Category` identified by our unique key.
  categoryPatch: CategoryPatch!
}

# All input for the `updateCategoryBySlug` mutation.
input UpdateCategoryBySlugInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  slug: String!

  # An object where the defined keys will be set on the `Category` identified by our unique key.
  categoryPatch: CategoryPatch!
}

# All input for the `updateCategory` mutation.
input UpdateCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Category` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Category` identified by our globally unique `ID`.
  categoryPatch: CategoryPatch!
}

# The output of our `updateCategory` mutation.
type UpdateCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  category: Category

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateClipById` mutation.
input UpdateClipByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `Clip` identified by our unique key.
  clipPatch: ClipPatch!
}

# All input for the `updateClipByOmnyClipId` mutation.
input UpdateClipByOmnyClipIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  omnyClipId: String!

  # An object where the defined keys will be set on the `Clip` identified by our unique key.
  clipPatch: ClipPatch!
}

# All input for the `updateClip` mutation.
input UpdateClipInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Clip` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Clip` identified by our globally unique `ID`.
  clipPatch: ClipPatch!
}

# The output of our `updateClip` mutation.
type UpdateClipPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  clip: Clip

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateDate` mutation.
input UpdateDateInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
}

# The output of our `updateDate` mutation.
type UpdateDatePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  string: String

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateFeaturedPodcastById` mutation.
input UpdateFeaturedPodcastByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `FeaturedPodcast` identified by our unique key.
  featuredPodcastPatch: FeaturedPodcastPatch!
}

# All input for the `updateFeaturedPodcastByPodcastIdAndMarketId` mutation.
input UpdateFeaturedPodcastByPodcastIdAndMarketIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  podcastId: Int!
  marketId: Int!

  # An object where the defined keys will be set on the `FeaturedPodcast` identified by our unique key.
  featuredPodcastPatch: FeaturedPodcastPatch!
}

# All input for the `updateFeaturedPodcast` mutation.
input UpdateFeaturedPodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FeaturedPodcast` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `FeaturedPodcast` identified by our globally unique `ID`.
  featuredPodcastPatch: FeaturedPodcastPatch!
}

# The output of our `updateFeaturedPodcast` mutation.
type UpdateFeaturedPodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  featuredPodcast: FeaturedPodcast

  # Reads a single `Podcast` that is related to this `FeaturedPodcast`.
  podcastByPodcastId: Podcast

  # Reads a single `Market` that is related to this `FeaturedPodcast`.
  marketByMarketId: Market

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateFeaturedStationById` mutation.
input UpdateFeaturedStationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `FeaturedStation` identified by our unique key.
  featuredStationPatch: FeaturedStationPatch!
}

# All input for the `updateFeaturedStationByStationIdAndMarketId` mutation.
input UpdateFeaturedStationByStationIdAndMarketIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  stationId: Int!
  marketId: Int!

  # An object where the defined keys will be set on the `FeaturedStation` identified by our unique key.
  featuredStationPatch: FeaturedStationPatch!
}

# All input for the `updateFeaturedStation` mutation.
input UpdateFeaturedStationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `FeaturedStation` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `FeaturedStation` identified by our globally unique `ID`.
  featuredStationPatch: FeaturedStationPatch!
}

# The output of our `updateFeaturedStation` mutation.
type UpdateFeaturedStationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  featuredStation: FeaturedStation

  # Reads a single `Station` that is related to this `FeaturedStation`.
  stationByStationId: Station

  # Reads a single `Market` that is related to this `FeaturedStation`.
  marketByMarketId: Market

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateGenreById` mutation.
input UpdateGenreByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `Genre` identified by our unique key.
  genrePatch: GenrePatch!
}

# All input for the `updateGenreByName` mutation.
input UpdateGenreByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!

  # An object where the defined keys will be set on the `Genre` identified by our unique key.
  genrePatch: GenrePatch!
}

# All input for the `updateGenreBySlug` mutation.
input UpdateGenreBySlugInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  slug: String!

  # An object where the defined keys will be set on the `Genre` identified by our unique key.
  genrePatch: GenrePatch!
}

# All input for the `updateGenre` mutation.
input UpdateGenreInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Genre` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Genre` identified by our globally unique `ID`.
  genrePatch: GenrePatch!
}

# The output of our `updateGenre` mutation.
type UpdateGenrePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  genre: Genre

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateMarketById` mutation.
input UpdateMarketByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `Market` identified by our unique key.
  marketPatch: MarketPatch!
}

# All input for the `updateMarketByName` mutation.
input UpdateMarketByNameInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  name: String!

  # An object where the defined keys will be set on the `Market` identified by our unique key.
  marketPatch: MarketPatch!
}

# All input for the `updateMarket` mutation.
input UpdateMarketInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Market` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Market` identified by our globally unique `ID`.
  marketPatch: MarketPatch!
}

# The output of our `updateMarket` mutation.
type UpdateMarketPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  market: Market

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updatePlaylistById` mutation.
input UpdatePlaylistByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `Playlist` identified by our unique key.
  playlistPatch: PlaylistPatch!
}

# All input for the `updatePlaylistByOmnyPlaylistId` mutation.
input UpdatePlaylistByOmnyPlaylistIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  omnyPlaylistId: String!

  # An object where the defined keys will be set on the `Playlist` identified by our unique key.
  playlistPatch: PlaylistPatch!
}

# All input for the `updatePlaylistClipById` mutation.
input UpdatePlaylistClipByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `PlaylistClip` identified by our unique key.
  playlistClipPatch: PlaylistClipPatch!
}

# All input for the `updatePlaylistClipByPlaylistIdAndClipId` mutation.
input UpdatePlaylistClipByPlaylistIdAndClipIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  playlistId: Int!
  clipId: Int!

  # An object where the defined keys will be set on the `PlaylistClip` identified by our unique key.
  playlistClipPatch: PlaylistClipPatch!
}

# All input for the `updatePlaylistClip` mutation.
input UpdatePlaylistClipInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PlaylistClip` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `PlaylistClip` identified by our globally unique `ID`.
  playlistClipPatch: PlaylistClipPatch!
}

# The output of our `updatePlaylistClip` mutation.
type UpdatePlaylistClipPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  playlistClip: PlaylistClip

  # Reads a single `Playlist` that is related to this `PlaylistClip`.
  playlistByPlaylistId: Playlist

  # Reads a single `Clip` that is related to this `PlaylistClip`.
  clipByClipId: Clip

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updatePlaylist` mutation.
input UpdatePlaylistInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Playlist` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Playlist` identified by our globally unique `ID`.
  playlistPatch: PlaylistPatch!
}

# The output of our `updatePlaylist` mutation.
type UpdatePlaylistPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  playlist: Playlist

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updatePodcastById` mutation.
input UpdatePodcastByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `Podcast` identified by our unique key.
  podcastPatch: PodcastPatch!
}

# All input for the `updatePodcastByOmnyPlaylistId` mutation.
input UpdatePodcastByOmnyPlaylistIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  omnyPlaylistId: String!

  # An object where the defined keys will be set on the `Podcast` identified by our unique key.
  podcastPatch: PodcastPatch!
}

# All input for the `updatePodcastCategoryById` mutation.
input UpdatePodcastCategoryByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `PodcastCategory` identified by our unique key.
  podcastCategoryPatch: PodcastCategoryPatch!
}

# All input for the `updatePodcastCategoryByPodcastIdAndCategoryId` mutation.
input UpdatePodcastCategoryByPodcastIdAndCategoryIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  podcastId: Int!
  categoryId: Int!

  # An object where the defined keys will be set on the `PodcastCategory` identified by our unique key.
  podcastCategoryPatch: PodcastCategoryPatch!
}

# All input for the `updatePodcastCategory` mutation.
input UpdatePodcastCategoryInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PodcastCategory` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `PodcastCategory` identified by our globally unique `ID`.
  podcastCategoryPatch: PodcastCategoryPatch!
}

# The output of our `updatePodcastCategory` mutation.
type UpdatePodcastCategoryPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  podcastCategory: PodcastCategory

  # Reads a single `Podcast` that is related to this `PodcastCategory`.
  podcastByPodcastId: Podcast

  # Reads a single `Category` that is related to this `PodcastCategory`.
  categoryByCategoryId: Category

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updatePodcastClipById` mutation.
input UpdatePodcastClipByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `PodcastClip` identified by our unique key.
  podcastClipPatch: PodcastClipPatch!
}

# All input for the `updatePodcastClipByPodcastIdAndClipId` mutation.
input UpdatePodcastClipByPodcastIdAndClipIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  podcastId: Int!
  clipId: Int!

  # An object where the defined keys will be set on the `PodcastClip` identified by our unique key.
  podcastClipPatch: PodcastClipPatch!
}

# All input for the `updatePodcastClip` mutation.
input UpdatePodcastClipInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `PodcastClip` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `PodcastClip` identified by our globally unique `ID`.
  podcastClipPatch: PodcastClipPatch!
}

# The output of our `updatePodcastClip` mutation.
type UpdatePodcastClipPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  podcastClip: PodcastClip

  # Reads a single `Podcast` that is related to this `PodcastClip`.
  podcastByPodcastId: Podcast

  # Reads a single `Clip` that is related to this `PodcastClip`.
  clipByClipId: Clip

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updatePodcast` mutation.
input UpdatePodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Podcast` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Podcast` identified by our globally unique `ID`.
  podcastPatch: PodcastPatch!
}

# The output of our `updatePodcast` mutation.
type UpdatePodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  podcast: Podcast

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateShowById` mutation.
input UpdateShowByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `Show` identified by our unique key.
  showPatch: ShowPatch!
}

# All input for the `updateShowByProgramId` mutation.
input UpdateShowByProgramIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  programId: String!

  # An object where the defined keys will be set on the `Show` identified by our unique key.
  showPatch: ShowPatch!
}

# All input for the `updateShow` mutation.
input UpdateShowInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Show` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Show` identified by our globally unique `ID`.
  showPatch: ShowPatch!
}

# All input for the `updateShowModuleById` mutation.
input UpdateShowModuleByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `ShowModule` identified by our unique key.
  showModulePatch: ShowModulePatch!
}

# All input for the `updateShowModuleCustomById` mutation.
input UpdateShowModuleCustomByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `ShowModuleCustom` identified by our unique key.
  showModuleCustomPatch: ShowModuleCustomPatch!
}

# All input for the `updateShowModuleCustom` mutation.
input UpdateShowModuleCustomInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ShowModuleCustom` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `ShowModuleCustom` identified by our globally unique `ID`.
  showModuleCustomPatch: ShowModuleCustomPatch!
}

# The output of our `updateShowModuleCustom` mutation.
type UpdateShowModuleCustomPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  showModuleCustom: ShowModuleCustom

  # Reads a single `ShowModule` that is related to this `ShowModuleCustom`.
  showModuleByShowModuleId: ShowModule

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateShowModule` mutation.
input UpdateShowModuleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ShowModule` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `ShowModule` identified by our globally unique `ID`.
  showModulePatch: ShowModulePatch!
}

# The output of our `updateShowModule` mutation.
type UpdateShowModulePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  showModule: ShowModule

  # Reads a single `Show` that is related to this `ShowModule`.
  showByShowId: Show

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `updateShow` mutation.
type UpdateShowPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  show: Show

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateShowPlaylistById` mutation.
input UpdateShowPlaylistByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `ShowPlaylist` identified by our unique key.
  showPlaylistPatch: ShowPlaylistPatch!
}

# All input for the `updateShowPlaylistByShowIdAndPlaylistId` mutation.
input UpdateShowPlaylistByShowIdAndPlaylistIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  showId: Int!
  playlistId: Int!

  # An object where the defined keys will be set on the `ShowPlaylist` identified by our unique key.
  showPlaylistPatch: ShowPlaylistPatch!
}

# All input for the `updateShowPlaylist` mutation.
input UpdateShowPlaylistInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ShowPlaylist` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `ShowPlaylist` identified by our globally unique `ID`.
  showPlaylistPatch: ShowPlaylistPatch!
}

# The output of our `updateShowPlaylist` mutation.
type UpdateShowPlaylistPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  showPlaylist: ShowPlaylist

  # Reads a single `Show` that is related to this `ShowPlaylist`.
  showByShowId: Show

  # Reads a single `Playlist` that is related to this `ShowPlaylist`.
  playlistByPlaylistId: Playlist

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateShowPodcastById` mutation.
input UpdateShowPodcastByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `ShowPodcast` identified by our unique key.
  showPodcastPatch: ShowPodcastPatch!
}

# All input for the `updateShowPodcastByShowIdAndPodcastId` mutation.
input UpdateShowPodcastByShowIdAndPodcastIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  showId: Int!
  podcastId: Int!

  # An object where the defined keys will be set on the `ShowPodcast` identified by our unique key.
  showPodcastPatch: ShowPodcastPatch!
}

# All input for the `updateShowPodcast` mutation.
input UpdateShowPodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `ShowPodcast` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `ShowPodcast` identified by our globally unique `ID`.
  showPodcastPatch: ShowPodcastPatch!
}

# The output of our `updateShowPodcast` mutation.
type UpdateShowPodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  showPodcast: ShowPodcast

  # Reads a single `Show` that is related to this `ShowPodcast`.
  showByShowId: Show

  # Reads a single `Podcast` that is related to this `ShowPodcast`.
  podcastByPodcastId: Podcast

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateSongById` mutation.
input UpdateSongByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `Song` identified by our unique key.
  songPatch: SongPatch!
}

# All input for the `updateSongByUfid` mutation.
input UpdateSongByUfidInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  ufid: String!

  # An object where the defined keys will be set on the `Song` identified by our unique key.
  songPatch: SongPatch!
}

# All input for the `updateSong` mutation.
input UpdateSongInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Song` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Song` identified by our globally unique `ID`.
  songPatch: SongPatch!
}

# The output of our `updateSong` mutation.
type UpdateSongPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  song: Song

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateSongPlayById` mutation.
input UpdateSongPlayByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `SongPlay` identified by our unique key.
  songPlayPatch: SongPlayPatch!
}

# All input for the `updateSongPlay` mutation.
input UpdateSongPlayInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `SongPlay` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `SongPlay` identified by our globally unique `ID`.
  songPlayPatch: SongPlayPatch!
}

# The output of our `updateSongPlay` mutation.
type UpdateSongPlayPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  songPlay: SongPlay

  # Reads a single `Song` that is related to this `SongPlay`.
  songBySongId: Song

  # Reads a single `Station` that is related to this `SongPlay`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateStationById` mutation.
input UpdateStationByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `Station` identified by our unique key.
  stationPatch: StationPatch!
}

# All input for the `updateStationByR20id` mutation.
input UpdateStationByR20idInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  r20id: Int!

  # An object where the defined keys will be set on the `Station` identified by our unique key.
  stationPatch: StationPatch!
}

# All input for the `updateStationGenreById` mutation.
input UpdateStationGenreByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `StationGenre` identified by our unique key.
  stationGenrePatch: StationGenrePatch!
}

# All input for the `updateStationGenreByStationIdAndGenreId` mutation.
input UpdateStationGenreByStationIdAndGenreIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  stationId: Int!
  genreId: Int!

  # An object where the defined keys will be set on the `StationGenre` identified by our unique key.
  stationGenrePatch: StationGenrePatch!
}

# All input for the `updateStationGenre` mutation.
input UpdateStationGenreInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationGenre` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `StationGenre` identified by our globally unique `ID`.
  stationGenrePatch: StationGenrePatch!
}

# The output of our `updateStationGenre` mutation.
type UpdateStationGenrePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationGenre: StationGenre

  # Reads a single `Station` that is related to this `StationGenre`.
  stationByStationId: Station

  # Reads a single `Genre` that is related to this `StationGenre`.
  genreByGenreId: Genre

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateStation` mutation.
input UpdateStationInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `Station` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `Station` identified by our globally unique `ID`.
  stationPatch: StationPatch!
}

# All input for the `updateStationModuleById` mutation.
input UpdateStationModuleByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `StationModule` identified by our unique key.
  stationModulePatch: StationModulePatch!
}

# All input for the `updateStationModuleCustomById` mutation.
input UpdateStationModuleCustomByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `StationModuleCustom` identified by our unique key.
  stationModuleCustomPatch: StationModuleCustomPatch!
}

# All input for the `updateStationModuleCustom` mutation.
input UpdateStationModuleCustomInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationModuleCustom` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `StationModuleCustom` identified by our globally unique `ID`.
  stationModuleCustomPatch: StationModuleCustomPatch!
}

# The output of our `updateStationModuleCustom` mutation.
type UpdateStationModuleCustomPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationModuleCustom: StationModuleCustom

  # Reads a single `StationModule` that is related to this `StationModuleCustom`.
  stationModuleByStationModuleId: StationModule

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateStationModule` mutation.
input UpdateStationModuleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationModule` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `StationModule` identified by our globally unique `ID`.
  stationModulePatch: StationModulePatch!
}

# The output of our `updateStationModule` mutation.
type UpdateStationModulePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationModule: StationModule

  # Reads a single `Station` that is related to this `StationModule`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateStationMountById` mutation.
input UpdateStationMountByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `StationMount` identified by our unique key.
  stationMountPatch: StationMountPatch!
}

# All input for the `updateStationMount` mutation.
input UpdateStationMountInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationMount` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `StationMount` identified by our globally unique `ID`.
  stationMountPatch: StationMountPatch!
}

# The output of our `updateStationMount` mutation.
type UpdateStationMountPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationMount: StationMount

  # Reads a single `Station` that is related to this `StationMount`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# The output of our `updateStation` mutation.
type UpdateStationPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  station: Station

  # Reads a single `Market` that is related to this `Station`.
  marketByMarketId: Market

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateStationPlaylistById` mutation.
input UpdateStationPlaylistByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `StationPlaylist` identified by our unique key.
  stationPlaylistPatch: StationPlaylistPatch!
}

# All input for the `updateStationPlaylistByStationIdAndPlaylistId` mutation.
input UpdateStationPlaylistByStationIdAndPlaylistIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  stationId: Int!
  playlistId: Int!

  # An object where the defined keys will be set on the `StationPlaylist` identified by our unique key.
  stationPlaylistPatch: StationPlaylistPatch!
}

# All input for the `updateStationPlaylist` mutation.
input UpdateStationPlaylistInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationPlaylist` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `StationPlaylist` identified by our globally unique `ID`.
  stationPlaylistPatch: StationPlaylistPatch!
}

# The output of our `updateStationPlaylist` mutation.
type UpdateStationPlaylistPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationPlaylist: StationPlaylist

  # Reads a single `Station` that is related to this `StationPlaylist`.
  stationByStationId: Station

  # Reads a single `Playlist` that is related to this `StationPlaylist`.
  playlistByPlaylistId: Playlist

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateStationPodcastById` mutation.
input UpdateStationPodcastByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `StationPodcast` identified by our unique key.
  stationPodcastPatch: StationPodcastPatch!
}

# All input for the `updateStationPodcastByStationIdAndPodcastId` mutation.
input UpdateStationPodcastByStationIdAndPodcastIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  stationId: Int!
  podcastId: Int!

  # An object where the defined keys will be set on the `StationPodcast` identified by our unique key.
  stationPodcastPatch: StationPodcastPatch!
}

# All input for the `updateStationPodcast` mutation.
input UpdateStationPodcastInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationPodcast` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `StationPodcast` identified by our globally unique `ID`.
  stationPodcastPatch: StationPodcastPatch!
}

# The output of our `updateStationPodcast` mutation.
type UpdateStationPodcastPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationPodcast: StationPodcast

  # Reads a single `Station` that is related to this `StationPodcast`.
  stationByStationId: Station

  # Reads a single `Podcast` that is related to this `StationPodcast`.
  podcastByPodcastId: Podcast

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateStationShowById` mutation.
input UpdateStationShowByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `StationShow` identified by our unique key.
  stationShowPatch: StationShowPatch!
}

# All input for the `updateStationShow` mutation.
input UpdateStationShowInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationShow` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `StationShow` identified by our globally unique `ID`.
  stationShowPatch: StationShowPatch!
}

# The output of our `updateStationShow` mutation.
type UpdateStationShowPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationShow: StationShow

  # Reads a single `Station` that is related to this `StationShow`.
  stationByStationId: Station

  # Reads a single `Show` that is related to this `StationShow`.
  showByShowId: Show

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateStationShowScheduleById` mutation.
input UpdateStationShowScheduleByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `StationShowSchedule` identified by our unique key.
  stationShowSchedulePatch: StationShowSchedulePatch!
}

# All input for the `updateStationShowSchedule` mutation.
input UpdateStationShowScheduleInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationShowSchedule` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `StationShowSchedule` identified by our globally unique `ID`.
  stationShowSchedulePatch: StationShowSchedulePatch!
}

# The output of our `updateStationShowSchedule` mutation.
type UpdateStationShowSchedulePayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationShowSchedule: StationShowSchedule

  # Reads a single `StationShow` that is related to this `StationShowSchedule`.
  stationShowByStationShowId: StationShow

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# All input for the `updateStationStreamById` mutation.
input UpdateStationStreamByIdInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String
  id: Int!

  # An object where the defined keys will be set on the `StationStream` identified by our unique key.
  stationStreamPatch: StationStreamPatch!
}

# All input for the `updateStationStream` mutation.
input UpdateStationStreamInput {
  # An arbitrary string value with no semantic meaning. Will be included in the
  # payload verbatim. May be used to track mutations by the client.
  clientMutationId: String

  # The globally unique `ID` which will identify a single `StationStream` to be updated.
  nodeId: ID!

  # An object where the defined keys will be set on the `StationStream` identified by our globally unique `ID`.
  stationStreamPatch: StationStreamPatch!
}

# The output of our `updateStationStream` mutation.
type UpdateStationStreamPayload {
  # The exact same `clientMutationId` that was provided in the mutation input,
  # unchanged and unused. May be used by a client to track mutations.
  clientMutationId: String
  stationStream: StationStream

  # Reads a single `Station` that is related to this `StationStream`.
  stationByStationId: Station

  # Our root query field type. Allows us to run any query from our mutation payload.
  query: Query
}

# A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
scalar Uuid

